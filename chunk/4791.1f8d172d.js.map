{"version":3,"file":"chunk/4791.1f8d172d.js","mappings":"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","sources":["webpack://@snx-v3/liquidity/../../node_modules/eccrypto/browser.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/create-identity.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/util.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/public-key.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/cipher.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/decrypt-with-private-key.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/encrypt-with-public-key.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/public-key-by-private-key.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/recover-public-key.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/recover.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/sign.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/sign-transaction.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/tx-data-by-compiled.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/calculate-contract-address.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/hash.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/hex.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/vrs.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/dist/es/index.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/secp256k1/elliptic.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/secp256k1/lib/elliptic.js","webpack://@snx-v3/liquidity/../../node_modules/eth-crypto/node_modules/secp256k1/lib/index.js"],"sourcesContent":["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n","import { utils as ethersUtils, Wallet } from 'ethers';\nimport { stripHexPrefix } from 'ethereumjs-util';\nvar MIN_ENTROPY_SIZE = 128;\nvar keccak256 = ethersUtils.keccak256;\n\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    var innerHex = keccak256(ethersUtils.concat([ethersUtils.randomBytes(32), ethersUtils.randomBytes(32)]));\n    var middleHex = ethersUtils.concat([ethersUtils.concat([ethersUtils.randomBytes(32), innerHex]), ethersUtils.randomBytes(32)]);\n    var _outerHex = keccak256(middleHex);\n    return _outerHex;\n  }\n}\n\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\nexport function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var wallet = new Wallet(privateKey);\n  var identity = {\n    privateKey: privateKey,\n    // remove trailing '0x04'\n    publicKey: stripHexPrefix(wallet.publicKey).slice(2),\n    address: wallet.address\n  };\n  return identity;\n}","export function removeLeading0x(str) {\n  if (str.startsWith('0x')) return str.substring(2);else return str;\n}\nexport function addLeading0x(str) {\n  if (!str.startsWith('0x')) return '0x' + str;else return str;\n}\nexport function uint8ArrayToHex(arr) {\n  return Buffer.from(arr).toString('hex');\n}\nexport function hexToUnit8Array(str) {\n  return new Uint8Array(Buffer.from(str, 'hex'));\n}","import { publicKeyConvert } from 'secp256k1';\nimport { pubToAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { hexToUnit8Array, uint8ArrayToHex, addLeading0x } from './util';\nexport function compress(startsWith04) {\n  // add trailing 04 if not done before\n  var testBuffer = Buffer.from(startsWith04, 'hex');\n  if (testBuffer.length === 64) startsWith04 = '04' + startsWith04;\n  return uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith04), true));\n}\nexport function decompress(startsWith02Or03) {\n  // if already decompressed an not has trailing 04\n  var testBuffer = Buffer.from(startsWith02Or03, 'hex');\n  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;\n  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false));\n\n  // remove trailing 04\n  decompressed = decompressed.substring(2);\n  return decompressed;\n}\n\n/**\n * generates the ethereum-adress of the publicKey\n * We create the checksum-adress which is case-sensitive\n * @returns {string} address\n */\nexport function toAddress(publicKey) {\n  // normalize key\n  publicKey = decompress(publicKey);\n  var addressBuffer = pubToAddress(toBuffer(addLeading0x(publicKey)));\n  var checkSumAdress = toChecksumAddress(addLeading0x(addressBuffer.toString('hex')));\n  return checkSumAdress;\n}","import { compress, decompress } from './public-key';\nexport function stringify(cipher) {\n  if (typeof cipher === 'string') return cipher;\n\n  // use compressed key because it's smaller\n  var compressedKey = compress(cipher.ephemPublicKey);\n  var ret = Buffer.concat([Buffer.from(cipher.iv, 'hex'),\n  // 16bit\n  Buffer.from(compressedKey, 'hex'),\n  // 33bit\n  Buffer.from(cipher.mac, 'hex'),\n  // 32bit\n  Buffer.from(cipher.ciphertext, 'hex') // var bit\n  ]);\n\n  return ret.toString('hex');\n}\nexport function parse(str) {\n  if (typeof str !== 'string') return str;\n  var buf = Buffer.from(str, 'hex');\n  var ret = {\n    iv: buf.toString('hex', 0, 16),\n    ephemPublicKey: buf.toString('hex', 16, 49),\n    mac: buf.toString('hex', 49, 81),\n    ciphertext: buf.toString('hex', 81, buf.length)\n  };\n\n  // decompress publicKey\n  ret.ephemPublicKey = '04' + decompress(ret.ephemPublicKey);\n  return ret;\n}","import { decrypt } from 'eccrypto';\nimport { parse } from './cipher';\nimport { removeLeading0x } from './util';\nexport function decryptWithPrivateKey(privateKey, encrypted) {\n  encrypted = parse(encrypted);\n\n  // remove trailing '0x' from privateKey\n  var twoStripped = removeLeading0x(privateKey);\n  var encryptedBuffer = {\n    iv: Buffer.from(encrypted.iv, 'hex'),\n    ephemPublicKey: Buffer.from(encrypted.ephemPublicKey, 'hex'),\n    ciphertext: Buffer.from(encrypted.ciphertext, 'hex'),\n    mac: Buffer.from(encrypted.mac, 'hex')\n  };\n  return decrypt(Buffer.from(twoStripped, 'hex'), encryptedBuffer).then(function (decryptedBuffer) {\n    return decryptedBuffer.toString();\n  });\n}","import { encrypt } from 'eccrypto';\nimport { decompress } from './public-key';\nexport function encryptWithPublicKey(publicKey, message, opts) {\n  // ensure its an uncompressed publicKey\n  publicKey = decompress(publicKey);\n\n  // re-add the compression-flag\n  var pubString = '04' + publicKey;\n  return encrypt(Buffer.from(pubString, 'hex'), Buffer.from(message), opts ? opts : {}).then(function (encryptedBuffers) {\n    var encrypted = {\n      iv: encryptedBuffers.iv.toString('hex'),\n      ephemPublicKey: encryptedBuffers.ephemPublicKey.toString('hex'),\n      ciphertext: encryptedBuffers.ciphertext.toString('hex'),\n      mac: encryptedBuffers.mac.toString('hex')\n    };\n    return encrypted;\n  });\n}","import { privateToPublic, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\n\n/**\n * Generate publicKey from the privateKey.\n * This creates the uncompressed publicKey,\n * where 04 has stripped from left\n * @returns {string}\n */\nexport function publicKeyByPrivateKey(privateKey) {\n  privateKey = addLeading0x(privateKey);\n  var publicKeyBuffer = privateToPublic(toBuffer(privateKey));\n  return publicKeyBuffer.toString('hex');\n}","import { ecdsaRecover } from 'secp256k1';\nimport { removeLeading0x, hexToUnit8Array, uint8ArrayToHex } from './util';\n\n/**\n * returns the publicKey for the privateKey with which the messageHash was signed\n * @param  {string} signature\n * @param  {string} hash\n * @return {string} publicKey\n */\nexport function recoverPublicKey(signature, hash) {\n  signature = removeLeading0x(signature);\n\n  // split into v-value and sig\n  var sigOnly = signature.substring(0, signature.length - 2); // all but last 2 chars\n  var vValue = signature.slice(-2); // last 2 chars\n\n  var recoveryNumber = vValue === '1c' ? 1 : 0;\n  var pubKey = uint8ArrayToHex(ecdsaRecover(hexToUnit8Array(sigOnly), recoveryNumber, hexToUnit8Array(removeLeading0x(hash)), false));\n\n  // remove trailing '04'\n  pubKey = pubKey.slice(2);\n  return pubKey;\n}","import { recoverPublicKey } from './recover-public-key';\nimport { toAddress as addressByPublicKey } from './public-key';\n\n/**\n * returns the adress with which the messageHash was signed\n * @param  {string} sigString\n * @param  {string} hash\n * @return {string} address\n */\nexport function recover(sigString, hash) {\n  var pubkey = recoverPublicKey(sigString, hash);\n  var address = addressByPublicKey(pubkey);\n  return address;\n}","import { ecdsaSign as secp256k1_sign } from 'secp256k1';\nimport { addLeading0x, removeLeading0x } from './util';\n\n/**\n * signs the given message\n * we do not use sign from eth-lib because the pure secp256k1-version is 90% faster\n * @param  {string} privateKey\n * @param  {string} hash\n * @return {string} hexString\n */\nexport function sign(privateKey, hash) {\n  hash = addLeading0x(hash);\n  if (hash.length !== 66) throw new Error('EthCrypto.sign(): Can only sign hashes, given: ' + hash);\n  var sigObj = secp256k1_sign(new Uint8Array(Buffer.from(removeLeading0x(hash), 'hex')), new Uint8Array(Buffer.from(removeLeading0x(privateKey), 'hex')));\n  var recoveryId = sigObj.recid === 1 ? '1c' : '1b';\n  var newSignature = '0x' + Buffer.from(sigObj.signature).toString('hex') + recoveryId;\n  return newSignature;\n}","import { Transaction } from '@ethereumjs/tx';\nimport { publicKeyByPrivateKey } from './public-key-by-private-key';\nimport { toAddress as addressByPublicKey } from './public-key';\nexport function signTransaction(rawTx, privateKey) {\n  var txOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // check if privateKey->address matches rawTx.from\n  var publicKey = publicKeyByPrivateKey(privateKey);\n  var address = addressByPublicKey(publicKey);\n  if (address != rawTx.from) throw new Error('EthCrypto.signTransaction(): rawTx.from does not match the address of the privateKey');\n  var privateKeyBuffer = Buffer.from(privateKey.replace(/^.{2}/g, ''), 'hex');\n  var tx = Transaction.fromTxData(rawTx, txOptions);\n  var signedTx = tx.sign(privateKeyBuffer);\n  var serializedTx = signedTx.serialize().toString('hex');\n  return serializedTx;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { ContractFactory } from 'ethers';\nexport function txDataByCompiled(abi, bytecode, args) {\n  // solc returns a string which is often passed instead of the json\n  if (typeof abi === 'string') abi = JSON.parse(abi);\n\n  // Construct a Contract Factory\n  var factory = new ContractFactory(abi, '0x' + bytecode);\n  var deployTransaction = factory.getDeployTransaction.apply(factory, _toConsumableArray(args));\n  return deployTransaction.data;\n}","import { generateAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\nexport function calculateContractAddress(creatorAddress, nonce) {\n  var addressBuffer = generateAddress(toBuffer(addLeading0x(creatorAddress)), toBuffer(nonce));\n  var address = addressBuffer.toString('hex');\n  return toChecksumAddress(addLeading0x(address));\n}","import { utils as ethersUtils } from 'ethers';\nexport function keccak256(params) {\n  var types = [];\n  var values = [];\n  if (!Array.isArray(params)) {\n    types.push('string');\n    values.push(params);\n  } else {\n    params.forEach(function (p) {\n      types.push(p.type);\n      values.push(p.value);\n    });\n  }\n  return ethersUtils.solidityKeccak256(types, values);\n}\nexport var SIGN_PREFIX = '\\x19Ethereum Signed Message:\\n32';","/**\n * compress/decompress hex-strings to utf16 or base64\n * thx @juvian\n * @link https://stackoverflow.com/a/40471908/3443137\n */\n\nimport { removeLeading0x, addLeading0x } from './util';\nexport function compress(hex) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  hex = removeLeading0x(hex);\n\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) return Buffer.from(hex, 'hex').toString('base64');\n  var string = '';\n  while (hex.length % 4 != 0) {\n    // we need it to be multiple of 4\n    hex = '0' + hex;\n  }\n  for (var i = 0; i < hex.length; i += 4) {\n    // get char from ascii code which goes from 0 to 65536\n    string += String.fromCharCode(parseInt(hex.substring(i, i + 4), 16));\n  }\n  return string;\n}\nexport function decompress(compressedString) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) {\n    var ret = Buffer.from(compressedString, 'base64').toString('hex');\n    return addLeading0x(ret);\n  }\n  var hex = '';\n  for (var i = 0; i < compressedString.length; i++) {\n    // get character ascii code and convert to hexa string, adding necessary 0s\n    hex += ((i == 0 ? '' : '000') + compressedString.charCodeAt(i).toString(16)).slice(-4);\n  }\n  hex = hex.toLowerCase();\n  return addLeading0x(hex);\n}","import { utils as ethersUtils } from 'ethers';\n/**\n * split signature-hex into parts\n * @param  {string} hexString\n * @return {{v: string, r: string, s: string}}\n */\nexport function fromString(hexString) {\n  var arr = ethersUtils.splitSignature(hexString);\n  return {\n    // convert \"v\" to hex\n    v: \"0x\".concat(arr.v.toString(16)),\n    r: arr.r,\n    s: arr.s\n  };\n}\n\n/**\n * merge signature-parts to one string\n * @param  {{v: string, r: string, s: string}} sig\n * @return {string} hexString\n */\nexport function toString(sig) {\n  return ethersUtils.joinSignature(sig);\n}","import { createIdentity } from './create-identity';\nimport * as publicKey from './public-key';\nimport { decryptWithPrivateKey } from './decrypt-with-private-key';\nimport { encryptWithPublicKey } from './encrypt-with-public-key';\nimport * as cipher from './cipher';\nimport { publicKeyByPrivateKey } from './public-key-by-private-key';\nimport { recover } from './recover';\nimport { recoverPublicKey } from './recover-public-key';\nimport { sign } from './sign';\nimport { signTransaction } from './sign-transaction';\nimport { txDataByCompiled } from './tx-data-by-compiled';\nimport { calculateContractAddress } from './calculate-contract-address';\nimport * as hash from './hash';\nimport * as hex from './hex';\nimport * as vrs from './vrs';\nimport * as util from './util';\nexport { createIdentity, publicKey, decryptWithPrivateKey, encryptWithPublicKey, cipher, publicKeyByPrivateKey, recover, recoverPublicKey, sign, signTransaction, txDataByCompiled, calculateContractAddress, hash, hex, vrs, util };\nexport default {\n  createIdentity: createIdentity,\n  publicKey: publicKey,\n  decryptWithPrivateKey: decryptWithPrivateKey,\n  encryptWithPublicKey: encryptWithPublicKey,\n  cipher: cipher,\n  publicKeyByPrivateKey: publicKeyByPrivateKey,\n  recover: recover,\n  recoverPublicKey: recoverPublicKey,\n  sign: sign,\n  signTransaction: signTransaction,\n  txDataByCompiled: txDataByCompiled,\n  calculateContractAddress: calculateContractAddress,\n  hash: hash,\n  hex: hex,\n  vrs: vrs,\n  util: util\n};","module.exports = require('./lib')(require('./lib/elliptic'))\n","const EC = require('elliptic').ec\n\nconst ec = new EC('secp256k1')\nconst ecparams = ec.curve\n\n// Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\nconst BN = ecparams.n.constructor\n\nfunction loadCompressedPublicKey (first, xbuf) {\n  let x = new BN(xbuf)\n\n  // overflow\n  if (x.cmp(ecparams.p) >= 0) return null\n  x = x.toRed(ecparams.red)\n\n  // compute corresponding Y\n  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()\n  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()\n\n  return ec.keyPair({ pub: { x: x, y: y } })\n}\n\nfunction loadUncompressedPublicKey (first, xbuf, ybuf) {\n  let x = new BN(xbuf)\n  let y = new BN(ybuf)\n\n  // overflow\n  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null\n\n  x = x.toRed(ecparams.red)\n  y = y.toRed(ecparams.red)\n\n  // is odd flag\n  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null\n\n  // x*x*x + b = y*y\n  const x3 = x.redSqr().redIMul(x)\n  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null\n\n  return ec.keyPair({ pub: { x: x, y: y } })\n}\n\nfunction loadPublicKey (pubkey) {\n  // length should be validated in interface\n  const first = pubkey[0]\n  switch (first) {\n    case 0x02:\n    case 0x03:\n      if (pubkey.length !== 33) return null\n      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))\n    case 0x04:\n    case 0x06:\n    case 0x07:\n      if (pubkey.length !== 65) return null\n      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))\n    default:\n      return null\n  }\n}\n\nfunction savePublicKey (output, point) {\n  const pubkey = point.encode(null, output.length === 33)\n  // Loop should be faster because we do not need create extra Uint8Array\n  // output.set(new Uint8Array(pubkey))\n  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]\n}\n\nmodule.exports = {\n  contextRandomize () {\n    return 0\n  },\n\n  privateKeyVerify (seckey) {\n    const bn = new BN(seckey)\n    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1\n  },\n\n  privateKeyNegate (seckey) {\n    const bn = new BN(seckey)\n    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(negate)\n    return 0\n  },\n\n  privateKeyTweakAdd (seckey, tweak) {\n    const bn = new BN(tweak)\n    if (bn.cmp(ecparams.n) >= 0) return 1\n\n    bn.iadd(new BN(seckey))\n    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)\n    if (bn.isZero()) return 1\n\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(tweaked)\n\n    return 0\n  },\n\n  privateKeyTweakMul (seckey, tweak) {\n    let bn = new BN(tweak)\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1\n\n    bn.imul(new BN(seckey))\n    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)\n\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(tweaked)\n\n    return 0\n  },\n\n  publicKeyVerify (pubkey) {\n    const pair = loadPublicKey(pubkey)\n    return pair === null ? 1 : 0\n  },\n\n  publicKeyCreate (output, seckey) {\n    const bn = new BN(seckey)\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1\n\n    const point = ec.keyFromPrivate(seckey).getPublic()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyConvert (output, pubkey) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const point = pair.getPublic()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyNegate (output, pubkey) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const point = pair.getPublic()\n    point.y = point.y.redNeg()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyCombine (output, pubkeys) {\n    const pairs = new Array(pubkeys.length)\n    for (let i = 0; i < pubkeys.length; ++i) {\n      pairs[i] = loadPublicKey(pubkeys[i])\n      if (pairs[i] === null) return 1\n    }\n\n    let point = pairs[0].getPublic()\n    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)\n    if (point.isInfinity()) return 2\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyTweakAdd (output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    tweak = new BN(tweak)\n    if (tweak.cmp(ecparams.n) >= 0) return 2\n\n    const point = pair.getPublic().add(ecparams.g.mul(tweak))\n    if (point.isInfinity()) return 2\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyTweakMul (output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    tweak = new BN(tweak)\n    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2\n\n    const point = pair.getPublic().mul(tweak)\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  signatureNormalize (sig) {\n    const r = new BN(sig.subarray(0, 32))\n    const s = new BN(sig.subarray(32, 64))\n    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1\n\n    if (s.cmp(ec.nh) === 1) {\n      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)\n    }\n\n    return 0\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureExport (obj, sig) {\n    const sigR = sig.subarray(0, 32)\n    const sigS = sig.subarray(32, 64)\n    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1\n    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1\n\n    const { output } = obj\n\n    // Prepare R\n    let r = output.subarray(4, 4 + 33)\n    r[0] = 0x00\n    r.set(sigR, 1)\n\n    let lenR = 33\n    let posR = 0\n    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);\n\n    r = r.subarray(posR)\n    if (r[0] & 0x80) return 1\n    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1\n\n    // Prepare S\n    let s = output.subarray(6 + 33, 6 + 33 + 33)\n    s[0] = 0x00\n    s.set(sigS, 1)\n\n    let lenS = 33\n    let posS = 0\n    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);\n\n    s = s.subarray(posS)\n    if (s[0] & 0x80) return 1\n    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1\n\n    // Set output length for return\n    obj.outputlen = 6 + lenR + lenS\n\n    // Output in specified format\n    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n    output[0] = 0x30\n    output[1] = obj.outputlen - 2\n    output[2] = 0x02\n    output[3] = r.length\n    output.set(r, 4)\n    output[4 + lenR] = 0x02\n    output[5 + lenR] = s.length\n    output.set(s, 6 + lenR)\n\n    return 0\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureImport (output, sig) {\n    if (sig.length < 8) return 1\n    if (sig.length > 72) return 1\n    if (sig[0] !== 0x30) return 1\n    if (sig[1] !== sig.length - 2) return 1\n    if (sig[2] !== 0x02) return 1\n\n    const lenR = sig[3]\n    if (lenR === 0) return 1\n    if (5 + lenR >= sig.length) return 1\n    if (sig[4 + lenR] !== 0x02) return 1\n\n    const lenS = sig[5 + lenR]\n    if (lenS === 0) return 1\n    if ((6 + lenR + lenS) !== sig.length) return 1\n\n    if (sig[4] & 0x80) return 1\n    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1\n\n    if (sig[lenR + 6] & 0x80) return 1\n    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1\n\n    let sigR = sig.subarray(4, 4 + lenR)\n    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)\n    if (sigR.length > 32) return 1\n\n    let sigS = sig.subarray(6 + lenR)\n    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)\n    if (sigS.length > 32) throw new Error('S length is too long')\n\n    let r = new BN(sigR)\n    if (r.cmp(ecparams.n) >= 0) r = new BN(0)\n\n    let s = new BN(sig.subarray(6 + lenR))\n    if (s.cmp(ecparams.n) >= 0) s = new BN(0)\n\n    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)\n    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)\n\n    return 0\n  },\n\n  ecdsaSign (obj, message, seckey, data, noncefn) {\n    if (noncefn) {\n      const _noncefn = noncefn\n      noncefn = (counter) => {\n        const nonce = _noncefn(message, seckey, null, data, counter)\n\n        const isValid = nonce instanceof Uint8Array && nonce.length === 32\n        if (!isValid) throw new Error('This is the way')\n\n        return new BN(nonce)\n      }\n    }\n\n    const d = new BN(seckey)\n    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1\n\n    let sig\n    try {\n      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })\n    } catch (err) {\n      return 1\n    }\n\n    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)\n    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)\n    obj.recid = sig.recoveryParam\n\n    return 0\n  },\n\n  ecdsaVerify (sig, msg32, pubkey) {\n    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }\n\n    const sigr = new BN(sigObj.r)\n    const sigs = new BN(sigObj.s)\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1\n    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3\n\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 2\n\n    const point = pair.getPublic()\n    const isValid = ec.verify(msg32, sigObj, point)\n    return isValid ? 0 : 3\n  },\n\n  ecdsaRecover (output, sig, recid, msg32) {\n    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }\n\n    const sigr = new BN(sigObj.r)\n    const sigs = new BN(sigObj.s)\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1\n\n    if (sigr.isZero() || sigs.isZero()) return 2\n\n    // Can throw `throw new Error('Unable to find sencond key candinate');`\n    let point\n    try {\n      point = ec.recoverPubKey(msg32, sigObj, recid)\n    } catch (err) {\n      return 2\n    }\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const scalar = new BN(seckey)\n    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2\n\n    const point = pair.getPublic().mul(scalar)\n\n    if (hashfn === undefined) {\n      const data = point.encode(null, true)\n      const sha256 = ec.hash().update(data).digest()\n      for (let i = 0; i < 32; ++i) output[i] = sha256[i]\n    } else {\n      if (!xbuf) xbuf = new Uint8Array(32)\n      const x = point.getX().toArray('be', 32)\n      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]\n\n      if (!ybuf) ybuf = new Uint8Array(32)\n      const y = point.getY().toArray('be', 32)\n      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]\n\n      const hash = hashfn(xbuf, ybuf, data)\n\n      const isValid = hash instanceof Uint8Array && hash.length === output.length\n      if (!isValid) return 2\n\n      output.set(hash)\n    }\n\n    return 0\n  }\n}\n","const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n"],"names":["ec","EC","browserCrypto","g","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isValidPrivateKey","privateKey","x","isBuffer","length","compare","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","Promise","resolve","result","createHash","update","digest","getAes","op","iv","key","data","importKey","name","then","cryptoKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","getPublic","keyFromPrivate","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","exports","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","hash","encryptionKey","slice","dataToMac","hmac","createHmac","hmacSha256Sign","mac","sig","b1","b2","res","i","equalConstTime","macGood","MIN_ENTROPY_SIZE","keccak256","createIdentity","entropy","byteLength","innerHex","middleHex","createPrivateKey","wallet","Wallet","publicKey","stripHexPrefix","address","removeLeading0x","str","startsWith","substring","addLeading0x","uint8ArrayToHex","toString","hexToUnit8Array","compress","startsWith04","publicKeyConvert","decompress","startsWith02Or03","decompressed","toAddress","addressBuffer","pubToAddress","toBuffer","toChecksumAddress","stringify","compressedKey","parse","buf","ret","decryptWithPrivateKey","encrypted","twoStripped","encryptedBuffer","decryptedBuffer","encryptWithPublicKey","pubString","encryptedBuffers","publicKeyByPrivateKey","privateToPublic","recoverPublicKey","signature","sigOnly","recoveryNumber","pubKey","ecdsaRecover","recover","sigString","sign","sigObj","recoveryId","recid","signTransaction","rawTx","txOptions","arguments","undefined","privateKeyBuffer","replace","Transaction","fromTxData","serialize","_arrayLikeToArray","len","arr2","Array","_toConsumableArray","isArray","iter","Symbol","iterator","o","minLen","n","Object","prototype","call","constructor","test","TypeError","txDataByCompiled","abi","bytecode","args","JSON","factory","getDeployTransaction","apply","calculateContractAddress","creatorAddress","nonce","generateAddress","params","types","values","forEach","p","push","type","value","SIGN_PREFIX","hex","base64","string","String","fromCharCode","parseInt","compressedString","charCodeAt","toLowerCase","fromString","hexString","v","r","s","vrs","util","module","ecparams","curve","BN","loadPublicKey","pubkey","first","xbuf","cmp","toRed","red","y","redSqr","redIMul","redIAdd","b","redSqrt","isOdd","redNeg","keyPair","pub","loadCompressedPublicKey","subarray","ybuf","x3","redISub","isZero","loadUncompressedPublicKey","savePublicKey","output","point","encode","contextRandomize","privateKeyVerify","seckey","bn","privateKeyNegate","negate","sub","umod","toArrayLike","set","privateKeyTweakAdd","tweak","iadd","isub","tweaked","privateKeyTweakMul","imul","publicKeyVerify","publicKeyCreate","pair","publicKeyNegate","publicKeyCombine","pubkeys","pairs","add","isInfinity","publicKeyTweakAdd","mul","publicKeyTweakMul","signatureNormalize","nh","signatureExport","obj","sigR","sigS","lenR","posR","lenS","posS","outputlen","signatureImport","ecdsaSign","noncefn","_noncefn","counter","d","canonical","k","pers","err","recoveryParam","ecdsaVerify","msg32","sigr","sigs","verify","recoverPubKey","ecdh","hashfn","scalar","sha256","getX","getY","errors","cond","isUint8Array","join","includes","isCompressed","toTypeString","getAssertedOutput","secp256k1","seed","compressed","options"],"sourceRoot":""}