{"version":3,"file":"chunk/835.fe0e5fe6.js","mappings":"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","sources":["webpack://@snx-v3/liquidity/../src/config.ts","webpack://@snx-v3/liquidity/../src/endpoint.ts","webpack://@snx-v3/liquidity/../src/index.ts","webpack://@snx-v3/liquidity/../../src/types/chains.ts","webpack://@snx-v3/liquidity/../../src/types/common.ts","webpack://@snx-v3/liquidity/../../src/types/notifications.ts","webpack://@snx-v3/liquidity/../../src/types/safe-apps.ts","webpack://@snx-v3/liquidity/../../src/types/safe-info.ts","webpack://@snx-v3/liquidity/../../src/types/safe-messages.ts","webpack://@snx-v3/liquidity/../../src/types/transactions.ts","webpack://@snx-v3/liquidity/../src/utils.ts","webpack://@snx-v3/liquidity/../../src/version.ts","webpack://@snx-v3/liquidity/../../../src/communication/utils.ts","webpack://@snx-v3/liquidity/../../../src/communication/messageFormatter.ts","webpack://@snx-v3/liquidity/../../../src/communication/methods.ts","webpack://@snx-v3/liquidity/../../../src/communication/index.ts","webpack://@snx-v3/liquidity/../../../src/types/sdk.ts","webpack://@snx-v3/liquidity/../../../src/txs/index.ts","webpack://@snx-v3/liquidity/../../../src/eth/constants.ts","webpack://@snx-v3/liquidity/../../../src/eth/index.ts","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/formatAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/abi.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/encodeAbiParameters.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/hashSignature.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/regex.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toSignature.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/normalizeSignature.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toSignatureHash.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toFunctionSelector.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toEventSelector.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/getAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/constants/strings.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/signature/hashMessage.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/signature/toPrefixedMessage.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/regex.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/typedData.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/signature/hashTypedData.js","webpack://@snx-v3/liquidity/../../../src/safe/signatures.ts","webpack://@snx-v3/liquidity/../../../src/types/permissions.ts","webpack://@snx-v3/liquidity/../../../src/wallet/index.ts","webpack://@snx-v3/liquidity/../../../src/decorators/requirePermissions.ts","webpack://@snx-v3/liquidity/../../../src/safe/index.ts","webpack://@snx-v3/liquidity/../../src/sdk.ts","webpack://@snx-v3/liquidity/../../src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"import { InvalidDefinitionTypeError, } from '../../errors/abi.js';\nexport function formatAbiItem(abiItem, { includeName = false } = {}) {\n    if (abiItem.type !== 'function' &&\n        abiItem.type !== 'event' &&\n        abiItem.type !== 'error')\n        throw new InvalidDefinitionTypeError(abiItem.type);\n    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;\n}\nexport function formatAbiParams(params, { includeName = false } = {}) {\n    if (!params)\n        return '';\n    return params\n        .map((param) => formatAbiParam(param, { includeName }))\n        .join(includeName ? ', ' : ',');\n}\nfunction formatAbiParam(param, { includeName }) {\n    if (param.type.startsWith('tuple')) {\n        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;\n    }\n    return param.type + (includeName && param.name ? ` ${param.name}` : '');\n}\n//# sourceMappingURL=formatAbiItem.js.map","import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js';\nimport { size } from '../utils/data/size.js';\nimport { BaseError } from './base.js';\nexport class AbiConstructorNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'A constructor was not found on the ABI.',\n            'Make sure you are using the correct ABI and that the constructor exists on it.',\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiConstructorNotFoundError'\n        });\n    }\n}\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiConstructorParamsNotFoundError'\n        });\n    }\n}\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n    constructor({ data, size }) {\n        super([\n            `Data size of ${size} bytes is invalid.`,\n            'Size must be in increments of 32 bytes (size % 32 === 0).',\n        ].join('\\n'), { metaMessages: [`Data: ${data} (${size} bytes)`] });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiDecodingDataSizeInvalidError'\n        });\n    }\n}\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n    constructor({ data, params, size, }) {\n        super([`Data size of ${size} bytes is too small for given parameters.`].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiDecodingDataSizeTooSmallError'\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiDecodingZeroDataError'\n        });\n    }\n}\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super([\n            `ABI encoding array length mismatch for type ${type}.`,\n            `Expected length: ${expectedLength}`,\n            `Given length: ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEncodingArrayLengthMismatchError'\n        });\n    }\n}\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, value }) {\n        super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEncodingBytesSizeMismatchError'\n        });\n    }\n}\nexport class AbiEncodingLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding params/values length mismatch.',\n            `Expected length (params): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEncodingLengthMismatchError'\n        });\n    }\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n    constructor(errorName, { docsPath }) {\n        super([\n            `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n            'Cannot encode error result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the inputs exist on it.',\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiErrorInputsNotFoundError'\n        });\n    }\n}\nexport class AbiErrorNotFoundError extends BaseError {\n    constructor(errorName, { docsPath } = {}) {\n        super([\n            `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiErrorNotFoundError'\n        });\n    }\n}\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded error signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiErrorSignatureNotFoundError'\n        });\n        Object.defineProperty(this, \"signature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.signature = signature;\n    }\n}\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n    constructor({ docsPath }) {\n        super('Cannot extract event signature from empty topics.', {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEventSignatureEmptyTopicsError'\n        });\n    }\n}\nexport class AbiEventSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded event signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEventSignatureNotFoundError'\n        });\n    }\n}\nexport class AbiEventNotFoundError extends BaseError {\n    constructor(eventName, { docsPath } = {}) {\n        super([\n            `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiEventNotFoundError'\n        });\n    }\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n    constructor(functionName, { docsPath } = {}) {\n        super([\n            `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiFunctionNotFoundError'\n        });\n    }\n}\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n    constructor(functionName, { docsPath }) {\n        super([\n            `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n            'Cannot decode function result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiFunctionOutputsNotFoundError'\n        });\n    }\n}\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded function signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiFunctionSignatureNotFoundError'\n        });\n    }\n}\nexport class AbiItemAmbiguityError extends BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI items.', {\n            metaMessages: [\n                `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n                `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItemAmbiguityError'\n        });\n    }\n}\nexport class BytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, givenSize, }) {\n        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BytesSizeMismatchError'\n        });\n    }\n}\nexport class DecodeLogDataMismatch extends BaseError {\n    constructor({ abiItem, data, params, size, }) {\n        super([\n            `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n        ].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'DecodeLogDataMismatch'\n        });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n    constructor({ abiItem, param, }) {\n        super([\n            `Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : ''} on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'DecodeLogTopicsMismatch'\n        });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n    }\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid encoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiEncodingType'\n        });\n    }\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid decoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiDecodingType'\n        });\n    }\n}\nexport class InvalidArrayError extends BaseError {\n    constructor(value) {\n        super([`Value \"${value}\" is not a valid array.`].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidArrayError'\n        });\n    }\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n    constructor(type) {\n        super([\n            `\"${type}\" is not a valid definition type.`,\n            'Valid types: \"function\", \"event\", \"error\"',\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidDefinitionTypeError'\n        });\n    }\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n    constructor(type) {\n        super(`Type \"${type}\" is not supported for packed encoding.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnsupportedPackedAbiType'\n        });\n    }\n}\n//# sourceMappingURL=abi.js.map","import { AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, InvalidAbiEncodingTypeError, InvalidArrayError, } from '../../errors/abi.js';\nimport { InvalidAddressError, } from '../../errors/address.js';\nimport { BaseError } from '../../errors/base.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concat } from '../data/concat.js';\nimport { padHex } from '../data/pad.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { boolToHex, numberToHex, stringToHex, } from '../encoding/toHex.js';\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters(params, values) {\n    if (params.length !== values.length)\n        throw new AbiEncodingLengthMismatchError({\n            expectedLength: params.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParams = prepareParams({\n        params: params,\n        values: values,\n    });\n    const data = encodeParams(preparedParams);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\nfunction prepareParams({ params, values, }) {\n    const preparedParams = [];\n    for (let i = 0; i < params.length; i++) {\n        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));\n    }\n    return preparedParams;\n}\nfunction prepareParam({ param, value, }) {\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, { length, param: { ...param, type } });\n    }\n    if (param.type === 'tuple') {\n        return encodeTuple(value, {\n            param: param,\n        });\n    }\n    if (param.type === 'address') {\n        return encodeAddress(value);\n    }\n    if (param.type === 'bool') {\n        return encodeBool(value);\n    }\n    if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n        const signed = param.type.startsWith('int');\n        return encodeNumber(value, { signed });\n    }\n    if (param.type.startsWith('bytes')) {\n        return encodeBytes(value, { param });\n    }\n    if (param.type === 'string') {\n        return encodeString(value);\n    }\n    throw new InvalidAbiEncodingTypeError(param.type, {\n        docsPath: '/docs/contract/encodeAbiParameters',\n    });\n}\nfunction encodeParams(preparedParams) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParams = [];\n    const dynamicParams = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic) {\n            staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n            dynamicParams.push(encoded);\n            dynamicSize += size(encoded);\n        }\n        else {\n            staticParams.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return concat([...staticParams, ...dynamicParams]);\n}\nfunction encodeAddress(value) {\n    if (!isAddress(value))\n        throw new InvalidAddressError({ address: value });\n    return { dynamic: false, encoded: padHex(value.toLowerCase()) };\n}\nfunction encodeArray(value, { length, param, }) {\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiEncodingArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${param.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParams = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParam({ param, value: value[i] });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParams.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encodeParams(preparedParams);\n        if (dynamic) {\n            const length = numberToHex(preparedParams.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nfunction encodeBytes(value, { param }) {\n    const [, paramSize] = param.type.split('bytes');\n    const bytesSize = size(value);\n    if (!paramSize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = padHex(value_, {\n                dir: 'right',\n                size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n            });\n        return {\n            dynamic: true,\n            encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n        };\n    }\n    if (bytesSize !== Number.parseInt(paramSize))\n        throw new AbiEncodingBytesSizeMismatchError({\n            expectedSize: Number.parseInt(paramSize),\n            value,\n        });\n    return { dynamic: false, encoded: padHex(value, { dir: 'right' }) };\n}\nfunction encodeBool(value) {\n    if (typeof value !== 'boolean')\n        throw new BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\nfunction encodeNumber(value, { signed }) {\n    return {\n        dynamic: false,\n        encoded: numberToHex(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\nfunction encodeString(value) {\n    const hexValue = stringToHex(value);\n    const partsLength = Math.ceil(size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n            dir: 'right',\n        }));\n    }\n    return {\n        dynamic: true,\n        encoded: concat([\n            padHex(numberToHex(size(hexValue), { size: 32 })),\n            ...parts,\n        ]),\n    };\n}\nfunction encodeTuple(value, { param }) {\n    let dynamic = false;\n    const preparedParams = [];\n    for (let i = 0; i < param.components.length; i++) {\n        const param_ = param.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParam({\n            param: param_,\n            value: value[index],\n        });\n        preparedParams.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encodeParams(preparedParams)\n            : concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nexport function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n//# sourceMappingURL=encodeAbiParameters.js.map","import { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from './keccak256.js';\nconst hash = (value) => keccak256(toBytes(value));\nexport function hashSignature(sig) {\n    return hash(sig);\n}\n//# sourceMappingURL=hashSignature.js.map","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map","import { execTyped } from '../regex.js';\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter(abiParameter) {\n    let type = abiParameter.type;\n    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n        type = '(';\n        const length = abiParameter.components.length;\n        for (let i = 0; i < length; i++) {\n            const component = abiParameter.components[i];\n            type += formatAbiParameter(component);\n            if (i < length - 1)\n                type += ', ';\n        }\n        const result = execTyped(tupleRegex, abiParameter.type);\n        type += `)${result?.array ?? ''}`;\n        return formatAbiParameter({\n            ...abiParameter,\n            type,\n        });\n    }\n    // Add `indexed` to type if in `abiParameter`\n    if ('indexed' in abiParameter && abiParameter.indexed)\n        type = `${type} indexed`;\n    // Return human-readable ABI parameter\n    if (abiParameter.name)\n        return `${type} ${abiParameter.name}`;\n    return type;\n}\n//# sourceMappingURL=formatAbiParameter.js.map","import { formatAbiParameter, } from './formatAbiParameter.js';\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters(abiParameters) {\n    let params = '';\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        params += formatAbiParameter(abiParameter);\n        if (i !== length - 1)\n            params += ', ';\n    }\n    return params;\n}\n//# sourceMappingURL=formatAbiParameters.js.map","import { formatAbiItem } from 'abitype';\nimport { normalizeSignature, } from './normalizeSignature.js';\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def) => {\n    const def_ = (() => {\n        if (typeof def === 'string')\n            return def;\n        return formatAbiItem(def);\n    })();\n    return normalizeSignature(def_);\n};\n//# sourceMappingURL=toSignature.js.map","import { formatAbiParameters, } from './formatAbiParameters.js';\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem(abiItem) {\n    if (abiItem.type === 'function')\n        return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n            ? ` ${abiItem.stateMutability}`\n            : ''}${abiItem.outputs.length\n            ? ` returns (${formatAbiParameters(abiItem.outputs)})`\n            : ''}`;\n    if (abiItem.type === 'event')\n        return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'error')\n        return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'constructor')\n        return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    if (abiItem.type === 'fallback')\n        return 'fallback()';\n    return 'receive() external payable';\n}\n//# sourceMappingURL=formatAbiItem.js.map","import { BaseError } from '../../errors/base.js';\nexport function normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new BaseError('Unable to normalize signature.');\n    return result;\n}\n//# sourceMappingURL=normalizeSignature.js.map","import { hashSignature } from './hashSignature.js';\nimport { toSignature } from './toSignature.js';\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn) {\n    return hashSignature(toSignature(fn));\n}\n//# sourceMappingURL=toSignatureHash.js.map","import { slice } from '../data/slice.js';\nimport { toSignatureHash, } from './toSignatureHash.js';\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);\n//# sourceMappingURL=toFunctionSelector.js.map","import { toSignatureHash, } from './toSignatureHash.js';\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash;\n//# sourceMappingURL=toEventSelector.js.map","import { AbiItemAmbiguityError, } from '../../errors/abi.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nexport function getAbiItem(parameters) {\n    const { abi, args = [], name } = parameters;\n    const isSelector = isHex(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function')\n                return toFunctionSelector(abiItem) === name;\n            if (abiItem.type === 'event')\n                return toEventSelector(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        return undefined;\n    if (abiItems.length === 1)\n        return abiItems[0];\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return abiItem;\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AbiItemAmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    if (matchedAbiItem)\n        return matchedAbiItem;\n    return abiItems[0];\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return isAddress(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return isAddress(args[parameterIndex], { strict: false });\n            if (types.includes('address') && types.includes('bytes'))\n                return isAddress(args[parameterIndex], { strict: false });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=getAbiItem.js.map","import { AbiFunctionNotFoundError, } from '../../errors/abi.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeFunctionData';\nexport function prepareEncodeFunctionData(parameters) {\n    const { abi, args, functionName } = parameters;\n    let abiItem = abi[0];\n    if (functionName) {\n        const item = getAbiItem({\n            abi,\n            args,\n            name: functionName,\n        });\n        if (!item)\n            throw new AbiFunctionNotFoundError(functionName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'function')\n        throw new AbiFunctionNotFoundError(undefined, { docsPath });\n    return {\n        abi: [abiItem],\n        functionName: toFunctionSelector(formatAbiItem(abiItem)),\n    };\n}\n//# sourceMappingURL=prepareEncodeFunctionData.js.map","import { concatHex } from '../data/concat.js';\nimport { encodeAbiParameters, } from './encodeAbiParameters.js';\nimport { prepareEncodeFunctionData } from './prepareEncodeFunctionData.js';\nexport function encodeFunctionData(parameters) {\n    const { args } = parameters;\n    const { abi, functionName } = (() => {\n        if (parameters.abi.length === 1 &&\n            parameters.functionName?.startsWith('0x'))\n            return parameters;\n        return prepareEncodeFunctionData(parameters);\n    })();\n    const abiItem = abi[0];\n    const signature = functionName;\n    const data = 'inputs' in abiItem && abiItem.inputs\n        ? encodeAbiParameters(abiItem.inputs, args ?? [])\n        : undefined;\n    return concatHex([signature, data ?? '0x']);\n}\n//# sourceMappingURL=encodeFunctionData.js.map","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n';\n//# sourceMappingURL=strings.js.map","import { keccak256 } from '../hash/keccak256.js';\nimport { toPrefixedMessage } from './toPrefixedMessage.js';\nexport function hashMessage(message, to_) {\n    return keccak256(toPrefixedMessage(message), to_);\n}\n//# sourceMappingURL=hashMessage.js.map","import { presignMessagePrefix } from '../../constants/strings.js';\nimport { concat } from '../data/concat.js';\nimport { size } from '../data/size.js';\nimport { bytesToHex, stringToHex, } from '../encoding/toHex.js';\nexport function toPrefixedMessage(message_) {\n    const message = (() => {\n        if (typeof message_ === 'string')\n            return stringToHex(message_);\n        if (typeof message_.raw === 'string')\n            return message_.raw;\n        return bytesToHex(message_.raw);\n    })();\n    const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);\n    return concat([prefix, message]);\n}\n//# sourceMappingURL=toPrefixedMessage.js.map","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\n//# sourceMappingURL=regex.js.map","import { BytesSizeMismatchError } from '../errors/abi.js';\nimport { InvalidAddressError } from '../errors/address.js';\nimport { isAddress } from './address/isAddress.js';\nimport { size } from './data/size.js';\nimport { numberToHex } from './encoding/toHex.js';\nimport { bytesRegex, integerRegex } from './regex.js';\nimport { hashDomain, } from './signature/hashTypedData.js';\nimport { stringify } from './stringify.js';\nexport function serializeTypedData(parameters) {\n    const { domain: domain_, message: message_, primaryType, types, } = parameters;\n    const normalizeData = (struct, data_) => {\n        const data = { ...data_ };\n        for (const param of struct) {\n            const { name, type } = param;\n            if (type === 'address')\n                data[name] = data[name].toLowerCase();\n        }\n        return data;\n    };\n    const domain = (() => {\n        if (!types.EIP712Domain)\n            return {};\n        if (!domain_)\n            return {};\n        return normalizeData(types.EIP712Domain, domain_);\n    })();\n    const message = (() => {\n        if (primaryType === 'EIP712Domain')\n            return undefined;\n        return normalizeData(types[primaryType], message_);\n    })();\n    return stringify({ domain, message, primaryType, types });\n}\nexport function validateTypedData(parameters) {\n    const { domain, message, primaryType, types } = parameters;\n    const validateData = (struct, data) => {\n        for (const param of struct) {\n            const { name, type } = param;\n            const value = data[name];\n            const integerMatch = type.match(integerRegex);\n            if (integerMatch &&\n                (typeof value === 'number' || typeof value === 'bigint')) {\n                const [_type, base, size_] = integerMatch;\n                // If number cannot be cast to a sized hex value, it is out of range\n                // and will throw.\n                numberToHex(value, {\n                    signed: base === 'int',\n                    size: Number.parseInt(size_) / 8,\n                });\n            }\n            if (type === 'address' && typeof value === 'string' && !isAddress(value))\n                throw new InvalidAddressError({ address: value });\n            const bytesMatch = type.match(bytesRegex);\n            if (bytesMatch) {\n                const [_type, size_] = bytesMatch;\n                if (size_ && size(value) !== Number.parseInt(size_))\n                    throw new BytesSizeMismatchError({\n                        expectedSize: Number.parseInt(size_),\n                        givenSize: size(value),\n                    });\n            }\n            const struct = types[type];\n            if (struct)\n                validateData(struct, value);\n        }\n    };\n    // Validate domain types.\n    if (types.EIP712Domain && domain)\n        validateData(types.EIP712Domain, domain);\n    // Validate message types.\n    if (primaryType !== 'EIP712Domain')\n        validateData(types[primaryType], message);\n}\nexport function getTypesForEIP712Domain({ domain, }) {\n    return [\n        typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n        domain?.version && { name: 'version', type: 'string' },\n        typeof domain?.chainId === 'number' && {\n            name: 'chainId',\n            type: 'uint256',\n        },\n        domain?.verifyingContract && {\n            name: 'verifyingContract',\n            type: 'address',\n        },\n        domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean);\n}\nexport function domainSeparator({ domain }) {\n    return hashDomain({\n        domain,\n        types: {\n            EIP712Domain: getTypesForEIP712Domain({ domain }),\n        },\n    });\n}\n//# sourceMappingURL=typedData.js.map","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\nimport { encodeAbiParameters, } from '../abi/encodeAbiParameters.js';\nimport { concat } from '../data/concat.js';\nimport { toHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getTypesForEIP712Domain, validateTypedData, } from '../typedData.js';\nexport function hashTypedData(parameters) {\n    const { domain = {}, message, primaryType, } = parameters;\n    const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parameters.types,\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types,\n    });\n    const parts = ['0x1901'];\n    if (domain)\n        parts.push(hashDomain({\n            domain,\n            types: types,\n        }));\n    if (primaryType !== 'EIP712Domain')\n        parts.push(hashStruct({\n            data: message,\n            primaryType,\n            types: types,\n        }));\n    return keccak256(concat(parts));\n}\nexport function hashDomain({ domain, types, }) {\n    return hashStruct({\n        data: domain,\n        primaryType: 'EIP712Domain',\n        types,\n    });\n}\nexport function hashStruct({ data, primaryType, types, }) {\n    const encoded = encodeData({\n        data,\n        primaryType,\n        types,\n    });\n    return keccak256(encoded);\n}\nfunction encodeData({ data, primaryType, types, }) {\n    const encodedTypes = [{ type: 'bytes32' }];\n    const encodedValues = [hashType({ primaryType, types })];\n    for (const field of types[primaryType]) {\n        const [type, value] = encodeField({\n            types,\n            name: field.name,\n            type: field.type,\n            value: data[field.name],\n        });\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType({ primaryType, types, }) {\n    const encodedHashType = toHex(encodeType({ primaryType, types }));\n    return keccak256(encodedHashType);\n}\nexport function encodeType({ primaryType, types, }) {\n    let result = '';\n    const unsortedDeps = findTypeDependencies({ primaryType, types });\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\nfunction findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {\n    const match = primaryType_.match(/^\\w*/u);\n    const primaryType = match?.[0];\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies({ primaryType: field.type, types }, results);\n    }\n    return results;\n}\nfunction encodeField({ types, name, type, value, }) {\n    if (types[type] !== undefined) {\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeData({ data: value, primaryType: type, types })),\n        ];\n    }\n    if (type === 'bytes') {\n        const prepend = value.length % 2 ? '0' : '';\n        value = `0x${prepend + value.slice(2)}`;\n        return [{ type: 'bytes32' }, keccak256(value)];\n    }\n    if (type === 'string')\n        return [{ type: 'bytes32' }, keccak256(toHex(value))];\n    if (type.lastIndexOf(']') === type.length - 1) {\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField({\n            name,\n            type: parsedType,\n            types,\n            value: item,\n        }));\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),\n        ];\n    }\n    return [{ type }, value];\n}\n//# sourceMappingURL=hashTypedData.js.map"],"names":["exports","utils_1","require","makeUrl","baseUrl","path","pathParams","query","insertParams","stringifyQuery","params","url","fetchData","body","rawUrl","deleteData","endpoint_1","config_1","__exportStar","DEFAULT_BASE_URL","chainId","address","getEndpoint","pageUrl","currency","safe_address","transactionId","postEndpoint","encodedData","to","data","messageHash","message_hash","uuid","deleteEndpoint","RPC_AUTHENTICATION","GAS_PRICE_TYPE","FEATURES","TokenType","DeviceType","SafeAppAccessPolicyTypes","SafeAppFeatures","SafeAppSocialPlatforms","ImplementationVersionState","SafeMessageListItemType","SafeMessageStatus","Operation","TransactionStatus","TransferDirection","TransactionTokenType","SettingsInfoType","TransactionInfoType","ConflictType","TransactionListItemType","DetailedExecutionInfoType","LabelValue","isErrorResponse","parseResponse","resp","json","_a","headers","get","Error","statusText","ok","errTxt","code","message","template","Object","keys","reduce","result","key","str","value","replace","RegExp","replaceParam","String","searchParams","URLSearchParams","forEach","append","searchString","toString","options","method","JSON","stringify","fetch","dec2hex","dec","padStart","generateRequestId","window","len","arr","Uint8Array","crypto","getRandomValues","Array","from","join","generateId","Date","getTime","MessageFormatter","Methods","RestrictedMethods","makeRequest","id","env","sdkVersion","makeResponse","version","success","makeErrorResponse","error","constructor","allowedOrigins","debugMode","callbacks","Map","isServer","isValidMessage","origin","source","emptyOrMalformed","sentFromParentEl","parent","majorVersionNumber","parseInt","split","allowedSDKVersion","validOrigin","isArray","undefined","find","regExp","test","logIncomingMessage","msg","console","info","onParentMessage","handleIncomingMessage","payload","cb","delete","send","request","postMessage","Promise","resolve","reject","set","response","addEventListener","isObjectEIP712TypedData","obj","TXs","communicator","safeTxHash","getTxBySafeTxHash","messagePayload","signMessage","typedData","signTypedMessage","txs","length","sendTransactions","RPC_CALLS","inputFormatters","defaultBlockParam","arg","returnFullTxObjectParam","blockNumberToHex","Number","isInteger","Eth","call","buildRequest","formatters","getBalance","getCode","getStorageAt","getPastLogs","getBlockByHash","getBlockByNumber","getTransactionByHash","getTransactionReceipt","getTransactionCount","getGasPrice","getEstimateGas","transaction","setSafeSettings","args","formatter","i","rpcCall","abiItem","includeName","type","InvalidDefinitionTypeError","name","inputs","map","param","startsWith","components","slice","formatAbiParam","AbiEncodingArrayLengthMismatchError","expectedLength","givenLength","super","defineProperty","this","enumerable","configurable","writable","AbiEncodingBytesSizeMismatchError","expectedSize","size","AbiEncodingLengthMismatchError","AbiFunctionNotFoundError","functionName","docsPath","AbiItemAmbiguityError","x","y","metaMessages","BytesSizeMismatchError","givenSize","InvalidAbiEncodingTypeError","InvalidArrayError","encodeAbiParameters","values","preparedParams","push","prepareParam","prepareParams","encodeParams","arrayComponents","matches","match","getArrayComponents","dynamic","dynamicChild","preparedParam","encoded","concat","encodeArray","param_","encodeTuple","isAddress","pad","toLowerCase","encodeAddress","encodeBool","signed","encodeNumber","paramSize","bytesSize","value_","dir","Math","ceil","encodeBytes","hexValue","partsLength","parts","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","hash","keccak256","toBytes","tupleRegex","formatAbiParameter","abiParameter","regex","string","exec","groups","execTyped","array","indexed","formatAbiParameters","abiParameters","toSignature","def","signature","active","current","level","valid","char","includes","normalizeSignature","stateMutability","outputs","toSignatureHash","fn","sig","toFunctionSelector","toEventSelector","isArgOfType","argType","abiParameterType","strict","every","component","index","getAmbiguousTypes","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","prepareEncodeFunctionData","parameters","abi","item","isSelector","isHex","abiItems","filter","matchedAbiItem","ambiguousTypes","getAbiItem","encodeFunctionData","presignMessagePrefix","hashMessage","to_","message_","raw","prefix","toPrefixedMessage","getTypesForEIP712Domain","domain","verifyingContract","salt","Boolean","hashTypedData","primaryType","EIP712Domain","validateData","struct","integerMatch","_type","base","size_","bytesMatch","validateTypedData","hashStruct","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","encodedHashType","toHex","unsortedDeps","findTypeDependencies","deps","sort","t","encodeType","primaryType_","results","Set","has","add","lastIndexOf","parsedType","typeValuePairs","v","PERMISSIONS_REQUEST_REJECTED","PermissionsError","setPrototypeOf","prototype","Wallet","wallet_getPermissions","permissions","isPermissionRequestValid","wallet_requestPermissions","pr","hasPermission","required","some","permission","parentCapability","requirePermission","_","propertyKey","descriptor","originalMethod","wallet","currentPermissions","getPermissions","requestPermissions","apply","Safe","getChainInfo","getSafeInfo","getSafeBalances","safeInfo","getInfo","encodedIsValidSignatureCall","constant","payable","safeAddress","err","calculateMessageHash","calculateTypedMessageHash","typedMessage","toNumber","fields","primaryTypes","typeName","dataTypes","getOffChainSignature","check","isMessageHashSigned","checks","check1271Signature","bind","check1271SignatureBytes","getEnvironmentInfo","requestAddressBook","__decorate","opts","allowedDomains","debug","InterfaceCommunicator","eth","safe"],"sourceRoot":""}