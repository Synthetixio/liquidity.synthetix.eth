{"version":3,"file":"chunk/3495.7ff848b1.js","mappings":"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","sources":["webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/_assert.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/utils.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/regex.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/accounts/utils/parseAccount.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/constants/kzg.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/constants/number.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/constants/solidity.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/abi.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/address.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/blob.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/chain.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/contract.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/cursor.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/node.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/stateOverride.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/transaction.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/utils.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/encoding/fromBytes.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/decodeAbiParameters.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/decodeErrorResult.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/encodeAbiParameters.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/formatAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/getAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/address/getAddress.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/address/isAddress.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/blob/blobsToCommitments.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/blob/blobsToProofs.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/constants/blob.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/blob/toBlobSidecars.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/blob/toBlobs.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/chain/defineChain.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/cursor.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/concat.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/slice.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/encoding/toRlp.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/errors/getCallError.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/errors/getNodeError.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/formatters/block.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/formatters/extract.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/formatters/formatter.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/formatters/log.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/formatters/transaction.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/formatters/transactionReceipt.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/formatters/transactionRequest.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/_u64.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/sha3.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/keccak256.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/_md.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/sha256.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/sha256.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toEventSelector.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toFunctionSelector.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/hashSignature.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toSignature.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/normalizeSignature.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toSignatureHash.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/lru.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/regex.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/stringify.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/transaction/assertRequest.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/transaction/getTransactionType.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/unit/formatGwei.js"],"sourcesContent":["function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\nconst assert = {\n    number: anumber,\n    bytes: abytes,\n    hash: ahash,\n    exists: aexists,\n    output: aoutput,\n};\nexport default assert;\n//# sourceMappingURL=_assert.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map","export function parseAccount(account) {\n    if (typeof account === 'string')\n        return { address: account, type: 'json-rpc' };\n    return account;\n}\n//# sourceMappingURL=parseAccount.js.map","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\nexport const versionedHashVersionKzg = 1;\n//# sourceMappingURL=kzg.js.map","export const maxInt8 = 2n ** (8n - 1n) - 1n;\nexport const maxInt16 = 2n ** (16n - 1n) - 1n;\nexport const maxInt24 = 2n ** (24n - 1n) - 1n;\nexport const maxInt32 = 2n ** (32n - 1n) - 1n;\nexport const maxInt40 = 2n ** (40n - 1n) - 1n;\nexport const maxInt48 = 2n ** (48n - 1n) - 1n;\nexport const maxInt56 = 2n ** (56n - 1n) - 1n;\nexport const maxInt64 = 2n ** (64n - 1n) - 1n;\nexport const maxInt72 = 2n ** (72n - 1n) - 1n;\nexport const maxInt80 = 2n ** (80n - 1n) - 1n;\nexport const maxInt88 = 2n ** (88n - 1n) - 1n;\nexport const maxInt96 = 2n ** (96n - 1n) - 1n;\nexport const maxInt104 = 2n ** (104n - 1n) - 1n;\nexport const maxInt112 = 2n ** (112n - 1n) - 1n;\nexport const maxInt120 = 2n ** (120n - 1n) - 1n;\nexport const maxInt128 = 2n ** (128n - 1n) - 1n;\nexport const maxInt136 = 2n ** (136n - 1n) - 1n;\nexport const maxInt144 = 2n ** (144n - 1n) - 1n;\nexport const maxInt152 = 2n ** (152n - 1n) - 1n;\nexport const maxInt160 = 2n ** (160n - 1n) - 1n;\nexport const maxInt168 = 2n ** (168n - 1n) - 1n;\nexport const maxInt176 = 2n ** (176n - 1n) - 1n;\nexport const maxInt184 = 2n ** (184n - 1n) - 1n;\nexport const maxInt192 = 2n ** (192n - 1n) - 1n;\nexport const maxInt200 = 2n ** (200n - 1n) - 1n;\nexport const maxInt208 = 2n ** (208n - 1n) - 1n;\nexport const maxInt216 = 2n ** (216n - 1n) - 1n;\nexport const maxInt224 = 2n ** (224n - 1n) - 1n;\nexport const maxInt232 = 2n ** (232n - 1n) - 1n;\nexport const maxInt240 = 2n ** (240n - 1n) - 1n;\nexport const maxInt248 = 2n ** (248n - 1n) - 1n;\nexport const maxInt256 = 2n ** (256n - 1n) - 1n;\nexport const minInt8 = -(2n ** (8n - 1n));\nexport const minInt16 = -(2n ** (16n - 1n));\nexport const minInt24 = -(2n ** (24n - 1n));\nexport const minInt32 = -(2n ** (32n - 1n));\nexport const minInt40 = -(2n ** (40n - 1n));\nexport const minInt48 = -(2n ** (48n - 1n));\nexport const minInt56 = -(2n ** (56n - 1n));\nexport const minInt64 = -(2n ** (64n - 1n));\nexport const minInt72 = -(2n ** (72n - 1n));\nexport const minInt80 = -(2n ** (80n - 1n));\nexport const minInt88 = -(2n ** (88n - 1n));\nexport const minInt96 = -(2n ** (96n - 1n));\nexport const minInt104 = -(2n ** (104n - 1n));\nexport const minInt112 = -(2n ** (112n - 1n));\nexport const minInt120 = -(2n ** (120n - 1n));\nexport const minInt128 = -(2n ** (128n - 1n));\nexport const minInt136 = -(2n ** (136n - 1n));\nexport const minInt144 = -(2n ** (144n - 1n));\nexport const minInt152 = -(2n ** (152n - 1n));\nexport const minInt160 = -(2n ** (160n - 1n));\nexport const minInt168 = -(2n ** (168n - 1n));\nexport const minInt176 = -(2n ** (176n - 1n));\nexport const minInt184 = -(2n ** (184n - 1n));\nexport const minInt192 = -(2n ** (192n - 1n));\nexport const minInt200 = -(2n ** (200n - 1n));\nexport const minInt208 = -(2n ** (208n - 1n));\nexport const minInt216 = -(2n ** (216n - 1n));\nexport const minInt224 = -(2n ** (224n - 1n));\nexport const minInt232 = -(2n ** (232n - 1n));\nexport const minInt240 = -(2n ** (240n - 1n));\nexport const minInt248 = -(2n ** (248n - 1n));\nexport const minInt256 = -(2n ** (256n - 1n));\nexport const maxUint8 = 2n ** 8n - 1n;\nexport const maxUint16 = 2n ** 16n - 1n;\nexport const maxUint24 = 2n ** 24n - 1n;\nexport const maxUint32 = 2n ** 32n - 1n;\nexport const maxUint40 = 2n ** 40n - 1n;\nexport const maxUint48 = 2n ** 48n - 1n;\nexport const maxUint56 = 2n ** 56n - 1n;\nexport const maxUint64 = 2n ** 64n - 1n;\nexport const maxUint72 = 2n ** 72n - 1n;\nexport const maxUint80 = 2n ** 80n - 1n;\nexport const maxUint88 = 2n ** 88n - 1n;\nexport const maxUint96 = 2n ** 96n - 1n;\nexport const maxUint104 = 2n ** 104n - 1n;\nexport const maxUint112 = 2n ** 112n - 1n;\nexport const maxUint120 = 2n ** 120n - 1n;\nexport const maxUint128 = 2n ** 128n - 1n;\nexport const maxUint136 = 2n ** 136n - 1n;\nexport const maxUint144 = 2n ** 144n - 1n;\nexport const maxUint152 = 2n ** 152n - 1n;\nexport const maxUint160 = 2n ** 160n - 1n;\nexport const maxUint168 = 2n ** 168n - 1n;\nexport const maxUint176 = 2n ** 176n - 1n;\nexport const maxUint184 = 2n ** 184n - 1n;\nexport const maxUint192 = 2n ** 192n - 1n;\nexport const maxUint200 = 2n ** 200n - 1n;\nexport const maxUint208 = 2n ** 208n - 1n;\nexport const maxUint216 = 2n ** 216n - 1n;\nexport const maxUint224 = 2n ** 224n - 1n;\nexport const maxUint232 = 2n ** 232n - 1n;\nexport const maxUint240 = 2n ** 240n - 1n;\nexport const maxUint248 = 2n ** 248n - 1n;\nexport const maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=number.js.map","// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n    1: 'An `assert` condition failed.',\n    17: 'Arithmetic operation resulted in underflow or overflow.',\n    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n    33: 'Attempted to convert to an invalid type.',\n    34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n    49: 'Performed `.pop()` on an empty array',\n    50: 'Array index is out of bounds.',\n    65: 'Allocated too much memory or created an array which is too large.',\n    81: 'Attempted to call a zero-initialized variable of internal function type.',\n};\nexport const solidityError = {\n    inputs: [\n        {\n            name: 'message',\n            type: 'string',\n        },\n    ],\n    name: 'Error',\n    type: 'error',\n};\nexport const solidityPanic = {\n    inputs: [\n        {\n            name: 'reason',\n            type: 'uint256',\n        },\n    ],\n    name: 'Panic',\n    type: 'error',\n};\n//# sourceMappingURL=solidity.js.map","import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js';\nimport { size } from '../utils/data/size.js';\nimport { BaseError } from './base.js';\nexport class AbiConstructorNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'A constructor was not found on the ABI.',\n            'Make sure you are using the correct ABI and that the constructor exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiConstructorNotFoundError',\n        });\n    }\n}\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiConstructorParamsNotFoundError',\n        });\n    }\n}\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n    constructor({ data, size }) {\n        super([\n            `Data size of ${size} bytes is invalid.`,\n            'Size must be in increments of 32 bytes (size % 32 === 0).',\n        ].join('\\n'), {\n            metaMessages: [`Data: ${data} (${size} bytes)`],\n            name: 'AbiDecodingDataSizeInvalidError',\n        });\n    }\n}\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n    constructor({ data, params, size, }) {\n        super([`Data size of ${size} bytes is too small for given parameters.`].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n            name: 'AbiDecodingDataSizeTooSmallError',\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n            name: 'AbiDecodingZeroDataError',\n        });\n    }\n}\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super([\n            `ABI encoding array length mismatch for type ${type}.`,\n            `Expected length: ${expectedLength}`,\n            `Given length: ${givenLength}`,\n        ].join('\\n'), { name: 'AbiEncodingArrayLengthMismatchError' });\n    }\n}\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, value }) {\n        super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: 'AbiEncodingBytesSizeMismatchError' });\n    }\n}\nexport class AbiEncodingLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding params/values length mismatch.',\n            `Expected length (params): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'), { name: 'AbiEncodingLengthMismatchError' });\n    }\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n    constructor(errorName, { docsPath }) {\n        super([\n            `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n            'Cannot encode error result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the inputs exist on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorInputsNotFoundError',\n        });\n    }\n}\nexport class AbiErrorNotFoundError extends BaseError {\n    constructor(errorName, { docsPath } = {}) {\n        super([\n            `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorNotFoundError',\n        });\n    }\n}\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded error signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorSignatureNotFoundError',\n        });\n        Object.defineProperty(this, \"signature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.signature = signature;\n    }\n}\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n    constructor({ docsPath }) {\n        super('Cannot extract event signature from empty topics.', {\n            docsPath,\n            name: 'AbiEventSignatureEmptyTopicsError',\n        });\n    }\n}\nexport class AbiEventSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded event signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiEventSignatureNotFoundError',\n        });\n    }\n}\nexport class AbiEventNotFoundError extends BaseError {\n    constructor(eventName, { docsPath } = {}) {\n        super([\n            `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiEventNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n    constructor(functionName, { docsPath } = {}) {\n        super([\n            `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n    constructor(functionName, { docsPath }) {\n        super([\n            `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n            'Cannot decode function result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionOutputsNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded function signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionSignatureNotFoundError',\n        });\n    }\n}\nexport class AbiItemAmbiguityError extends BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI items.', {\n            metaMessages: [\n                `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n                `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n            name: 'AbiItemAmbiguityError',\n        });\n    }\n}\nexport class BytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, givenSize, }) {\n        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n            name: 'BytesSizeMismatchError',\n        });\n    }\n}\nexport class DecodeLogDataMismatch extends BaseError {\n    constructor({ abiItem, data, params, size, }) {\n        super([\n            `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n        ].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n            name: 'DecodeLogDataMismatch',\n        });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n    constructor({ abiItem, param, }) {\n        super([\n            `Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : ''} on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n        ].join('\\n'), { name: 'DecodeLogTopicsMismatch' });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n    }\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid encoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath, name: 'InvalidAbiEncodingType' });\n    }\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid decoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath, name: 'InvalidAbiDecodingType' });\n    }\n}\nexport class InvalidArrayError extends BaseError {\n    constructor(value) {\n        super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n            name: 'InvalidArrayError',\n        });\n    }\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n    constructor(type) {\n        super([\n            `\"${type}\" is not a valid definition type.`,\n            'Valid types: \"function\", \"event\", \"error\"',\n        ].join('\\n'), { name: 'InvalidDefinitionTypeError' });\n    }\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n    constructor(type) {\n        super(`Type \"${type}\" is not supported for packed encoding.`, {\n            name: 'UnsupportedPackedAbiType',\n        });\n    }\n}\n//# sourceMappingURL=abi.js.map","import { BaseError } from './base.js';\nexport class InvalidAddressError extends BaseError {\n    constructor({ address }) {\n        super(`Address \"${address}\" is invalid.`, {\n            metaMessages: [\n                '- Address must be a hex value of 20 bytes (40 hex characters).',\n                '- Address must match its checksum counterpart.',\n            ],\n            name: 'InvalidAddressError',\n        });\n    }\n}\n//# sourceMappingURL=address.js.map","import { versionedHashVersionKzg } from '../constants/kzg.js';\nimport { BaseError } from './base.js';\nexport class BlobSizeTooLargeError extends BaseError {\n    constructor({ maxSize, size }) {\n        super('Blob size is too large.', {\n            metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n            name: 'BlobSizeTooLargeError',\n        });\n    }\n}\nexport class EmptyBlobError extends BaseError {\n    constructor() {\n        super('Blob data must not be empty.', { name: 'EmptyBlobError' });\n    }\n}\nexport class InvalidVersionedHashSizeError extends BaseError {\n    constructor({ hash, size, }) {\n        super(`Versioned hash \"${hash}\" size is invalid.`, {\n            metaMessages: ['Expected: 32', `Received: ${size}`],\n            name: 'InvalidVersionedHashSizeError',\n        });\n    }\n}\nexport class InvalidVersionedHashVersionError extends BaseError {\n    constructor({ hash, version, }) {\n        super(`Versioned hash \"${hash}\" version is invalid.`, {\n            metaMessages: [\n                `Expected: ${versionedHashVersionKzg}`,\n                `Received: ${version}`,\n            ],\n            name: 'InvalidVersionedHashVersionError',\n        });\n    }\n}\n//# sourceMappingURL=blob.js.map","import { BaseError } from './base.js';\nexport class ChainDoesNotSupportContract extends BaseError {\n    constructor({ blockNumber, chain, contract, }) {\n        super(`Chain \"${chain.name}\" does not support contract \"${contract.name}\".`, {\n            metaMessages: [\n                'This could be due to any of the following:',\n                ...(blockNumber &&\n                    contract.blockCreated &&\n                    contract.blockCreated > blockNumber\n                    ? [\n                        `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n                    ]\n                    : [\n                        `- The chain does not have the contract \"${contract.name}\" configured.`,\n                    ]),\n            ],\n            name: 'ChainDoesNotSupportContract',\n        });\n    }\n}\nexport class ChainMismatchError extends BaseError {\n    constructor({ chain, currentChainId, }) {\n        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {\n            metaMessages: [\n                `Current Chain ID:  ${currentChainId}`,\n                `Expected Chain ID: ${chain.id} – ${chain.name}`,\n            ],\n            name: 'ChainMismatchError',\n        });\n    }\n}\nexport class ChainNotFoundError extends BaseError {\n    constructor() {\n        super([\n            'No chain was provided to the request.',\n            'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n        ].join('\\n'), {\n            name: 'ChainNotFoundError',\n        });\n    }\n}\nexport class ClientChainNotConfiguredError extends BaseError {\n    constructor() {\n        super('No chain was provided to the Client.', {\n            name: 'ClientChainNotConfiguredError',\n        });\n    }\n}\nexport class InvalidChainIdError extends BaseError {\n    constructor({ chainId }) {\n        super(typeof chainId === 'number'\n            ? `Chain ID \"${chainId}\" is invalid.`\n            : 'Chain ID is invalid.', { name: 'InvalidChainIdError' });\n    }\n}\n//# sourceMappingURL=chain.js.map","import { stringify } from '../stringify.js';\nexport function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false, }) {\n    if (!('name' in abiItem))\n        return;\n    if (!('inputs' in abiItem))\n        return;\n    if (!abiItem.inputs)\n        return;\n    return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs\n        .map((input, i) => `${includeName && input.name ? `${input.name}: ` : ''}${typeof args[i] === 'object' ? stringify(args[i]) : args[i]}`)\n        .join(', ')})`;\n}\n//# sourceMappingURL=formatAbiItemWithArgs.js.map","import { parseAccount } from '../accounts/utils/parseAccount.js';\nimport { panicReasons } from '../constants/solidity.js';\nimport { decodeErrorResult, } from '../utils/abi/decodeErrorResult.js';\nimport { formatAbiItem } from '../utils/abi/formatAbiItem.js';\nimport { formatAbiItemWithArgs } from '../utils/abi/formatAbiItemWithArgs.js';\nimport { getAbiItem } from '../utils/abi/getAbiItem.js';\nimport { formatEther } from '../utils/unit/formatEther.js';\nimport { formatGwei } from '../utils/unit/formatGwei.js';\nimport { AbiErrorSignatureNotFoundError } from './abi.js';\nimport { BaseError } from './base.js';\nimport { prettyStateOverride } from './stateOverride.js';\nimport { prettyPrint } from './transaction.js';\nimport { getContractAddress } from './utils.js';\nexport class CallExecutionError extends BaseError {\n    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, }) {\n        const account = account_ ? parseAccount(account_) : undefined;\n        let prettyArgs = prettyPrint({\n            from: account?.address,\n            to,\n            value: typeof value !== 'undefined' &&\n                `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n            data,\n            gas,\n            gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&\n                `${formatGwei(maxFeePerGas)} gwei`,\n            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&\n                `${formatGwei(maxPriorityFeePerGas)} gwei`,\n            nonce,\n        });\n        if (stateOverride) {\n            prettyArgs += `\\n${prettyStateOverride(stateOverride)}`;\n        }\n        super(cause.shortMessage, {\n            cause,\n            docsPath,\n            metaMessages: [\n                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n                'Raw Call Arguments:',\n                prettyArgs,\n            ].filter(Boolean),\n            name: 'CallExecutionError',\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cause = cause;\n    }\n}\nexport class ContractFunctionExecutionError extends BaseError {\n    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender, }) {\n        const abiItem = getAbiItem({ abi, args, name: functionName });\n        const formattedArgs = abiItem\n            ? formatAbiItemWithArgs({\n                abiItem,\n                args,\n                includeFunctionName: false,\n                includeName: false,\n            })\n            : undefined;\n        const functionWithParams = abiItem\n            ? formatAbiItem(abiItem, { includeName: true })\n            : undefined;\n        const prettyArgs = prettyPrint({\n            address: contractAddress && getContractAddress(contractAddress),\n            function: functionWithParams,\n            args: formattedArgs &&\n                formattedArgs !== '()' &&\n                `${[...Array(functionName?.length ?? 0).keys()]\n                    .map(() => ' ')\n                    .join('')}${formattedArgs}`,\n            sender,\n        });\n        super(cause.shortMessage ||\n            `An unknown error occurred while executing the contract function \"${functionName}\".`, {\n            cause,\n            docsPath,\n            metaMessages: [\n                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n                prettyArgs && 'Contract Call:',\n                prettyArgs,\n            ].filter(Boolean),\n            name: 'ContractFunctionExecutionError',\n        });\n        Object.defineProperty(this, \"abi\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"args\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"contractAddress\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"formattedArgs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"functionName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sender\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abi = abi;\n        this.args = args;\n        this.cause = cause;\n        this.contractAddress = contractAddress;\n        this.functionName = functionName;\n        this.sender = sender;\n    }\n}\nexport class ContractFunctionRevertedError extends BaseError {\n    constructor({ abi, data, functionName, message, }) {\n        let cause;\n        let decodedData = undefined;\n        let metaMessages;\n        let reason;\n        if (data && data !== '0x') {\n            try {\n                decodedData = decodeErrorResult({ abi, data });\n                const { abiItem, errorName, args: errorArgs } = decodedData;\n                if (errorName === 'Error') {\n                    reason = errorArgs[0];\n                }\n                else if (errorName === 'Panic') {\n                    const [firstArg] = errorArgs;\n                    reason = panicReasons[firstArg];\n                }\n                else {\n                    const errorWithParams = abiItem\n                        ? formatAbiItem(abiItem, { includeName: true })\n                        : undefined;\n                    const formattedArgs = abiItem && errorArgs\n                        ? formatAbiItemWithArgs({\n                            abiItem,\n                            args: errorArgs,\n                            includeFunctionName: false,\n                            includeName: false,\n                        })\n                        : undefined;\n                    metaMessages = [\n                        errorWithParams ? `Error: ${errorWithParams}` : '',\n                        formattedArgs && formattedArgs !== '()'\n                            ? `       ${[...Array(errorName?.length ?? 0).keys()]\n                                .map(() => ' ')\n                                .join('')}${formattedArgs}`\n                            : '',\n                    ];\n                }\n            }\n            catch (err) {\n                cause = err;\n            }\n        }\n        else if (message)\n            reason = message;\n        let signature;\n        if (cause instanceof AbiErrorSignatureNotFoundError) {\n            signature = cause.signature;\n            metaMessages = [\n                `Unable to decode signature \"${signature}\" as it was not found on the provided ABI.`,\n                'Make sure you are using the correct ABI and that the error exists on it.',\n                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n            ];\n        }\n        super((reason && reason !== 'execution reverted') || signature\n            ? [\n                `The contract function \"${functionName}\" reverted with the following ${signature ? 'signature' : 'reason'}:`,\n                reason || signature,\n            ].join('\\n')\n            : `The contract function \"${functionName}\" reverted.`, {\n            cause,\n            metaMessages,\n            name: 'ContractFunctionRevertedError',\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reason\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"signature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = decodedData;\n        this.reason = reason;\n        this.signature = signature;\n    }\n}\nexport class ContractFunctionZeroDataError extends BaseError {\n    constructor({ functionName }) {\n        super(`The contract function \"${functionName}\" returned no data (\"0x\").`, {\n            metaMessages: [\n                'This could be due to any of the following:',\n                `  - The contract does not have the function \"${functionName}\",`,\n                '  - The parameters passed to the contract function may be invalid, or',\n                '  - The address is not a contract.',\n            ],\n            name: 'ContractFunctionZeroDataError',\n        });\n    }\n}\nexport class CounterfactualDeploymentFailedError extends BaseError {\n    constructor({ factory }) {\n        super(`Deployment for counterfactual contract call failed${factory ? ` for factory \"${factory}\".` : ''}`, {\n            metaMessages: [\n                'Please ensure:',\n                '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',\n                '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.',\n            ],\n            name: 'CounterfactualDeploymentFailedError',\n        });\n    }\n}\nexport class RawContractError extends BaseError {\n    constructor({ data, message, }) {\n        super(message || '', { name: 'RawContractError' });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = data;\n    }\n}\n//# sourceMappingURL=contract.js.map","import { BaseError } from './base.js';\nexport class NegativeOffsetError extends BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`, {\n            name: 'NegativeOffsetError',\n        });\n    }\n}\nexport class PositionOutOfBoundsError extends BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`, { name: 'PositionOutOfBoundsError' });\n    }\n}\nexport class RecursiveReadLimitExceededError extends BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`, { name: 'RecursiveReadLimitExceededError' });\n    }\n}\n//# sourceMappingURL=cursor.js.map","import { formatGwei } from '../utils/unit/formatGwei.js';\nimport { BaseError } from './base.js';\nexport class ExecutionRevertedError extends BaseError {\n    constructor({ cause, message, } = {}) {\n        const reason = message\n            ?.replace('execution reverted: ', '')\n            ?.replace('execution reverted', '');\n        super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {\n            cause,\n            name: 'ExecutionRevertedError',\n        });\n    }\n}\nObject.defineProperty(ExecutionRevertedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 3\n});\nObject.defineProperty(ExecutionRevertedError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /execution reverted/\n});\nexport class FeeCapTooHighError extends BaseError {\n    constructor({ cause, maxFeePerGas, } = {}) {\n        super(`The fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {\n            cause,\n            name: 'FeeCapTooHighError',\n        });\n    }\n}\nObject.defineProperty(FeeCapTooHighError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n});\nexport class FeeCapTooLowError extends BaseError {\n    constructor({ cause, maxFeePerGas, } = {}) {\n        super(`The fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {\n            cause,\n            name: 'FeeCapTooLowError',\n        });\n    }\n}\nObject.defineProperty(FeeCapTooLowError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n});\nexport class NonceTooHighError extends BaseError {\n    constructor({ cause, nonce, } = {}) {\n        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, { cause, name: 'NonceTooHighError' });\n    }\n}\nObject.defineProperty(NonceTooHighError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /nonce too high/\n});\nexport class NonceTooLowError extends BaseError {\n    constructor({ cause, nonce, } = {}) {\n        super([\n            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`,\n            'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n        ].join('\\n'), { cause, name: 'NonceTooLowError' });\n    }\n}\nObject.defineProperty(NonceTooLowError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /nonce too low|transaction already imported|already known/\n});\nexport class NonceMaxValueError extends BaseError {\n    constructor({ cause, nonce, } = {}) {\n        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, { cause, name: 'NonceMaxValueError' });\n    }\n}\nObject.defineProperty(NonceMaxValueError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /nonce has max value/\n});\nexport class InsufficientFundsError extends BaseError {\n    constructor({ cause } = {}) {\n        super([\n            'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n        ].join('\\n'), {\n            cause,\n            metaMessages: [\n                'This error could arise when the account does not have enough funds to:',\n                ' - pay for the total gas fee,',\n                ' - pay for the value to send.',\n                ' ',\n                'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n                ' - `gas` is the amount of gas needed for transaction to execute,',\n                ' - `gas fee` is the gas fee,',\n                ' - `value` is the amount of ether to send to the recipient.',\n            ],\n            name: 'InsufficientFundsError',\n        });\n    }\n}\nObject.defineProperty(InsufficientFundsError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /insufficient funds|exceeds transaction sender account balance/\n});\nexport class IntrinsicGasTooHighError extends BaseError {\n    constructor({ cause, gas, } = {}) {\n        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {\n            cause,\n            name: 'IntrinsicGasTooHighError',\n        });\n    }\n}\nObject.defineProperty(IntrinsicGasTooHighError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /intrinsic gas too high|gas limit reached/\n});\nexport class IntrinsicGasTooLowError extends BaseError {\n    constructor({ cause, gas, } = {}) {\n        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {\n            cause,\n            name: 'IntrinsicGasTooLowError',\n        });\n    }\n}\nObject.defineProperty(IntrinsicGasTooLowError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /intrinsic gas too low/\n});\nexport class TransactionTypeNotSupportedError extends BaseError {\n    constructor({ cause }) {\n        super('The transaction type is not supported for this chain.', {\n            cause,\n            name: 'TransactionTypeNotSupportedError',\n        });\n    }\n}\nObject.defineProperty(TransactionTypeNotSupportedError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /transaction type not valid/\n});\nexport class TipAboveFeeCapError extends BaseError {\n    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas, } = {}) {\n        super([\n            `The provided tip (\\`maxPriorityFeePerGas\\`${maxPriorityFeePerGas\n                ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n                : ''}) cannot be higher than the fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}).`,\n        ].join('\\n'), {\n            cause,\n            name: 'TipAboveFeeCapError',\n        });\n    }\n}\nObject.defineProperty(TipAboveFeeCapError, \"nodeMessage\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n});\nexport class UnknownNodeError extends BaseError {\n    constructor({ cause }) {\n        super(`An error occurred while executing: ${cause?.shortMessage}`, {\n            cause,\n            name: 'UnknownNodeError',\n        });\n    }\n}\n//# sourceMappingURL=node.js.map","import { BaseError } from './base.js';\nexport class AccountStateConflictError extends BaseError {\n    constructor({ address }) {\n        super(`State for account \"${address}\" is set multiple times.`, {\n            name: 'AccountStateConflictError',\n        });\n    }\n}\nexport class StateAssignmentConflictError extends BaseError {\n    constructor() {\n        super('state and stateDiff are set on the same account.', {\n            name: 'StateAssignmentConflictError',\n        });\n    }\n}\n/** @internal */\nexport function prettyStateMapping(stateMapping) {\n    return stateMapping.reduce((pretty, { slot, value }) => {\n        return `${pretty}        ${slot}: ${value}\\n`;\n    }, '');\n}\nexport function prettyStateOverride(stateOverride) {\n    return stateOverride\n        .reduce((pretty, { address, ...state }) => {\n        let val = `${pretty}    ${address}:\\n`;\n        if (state.nonce)\n            val += `      nonce: ${state.nonce}\\n`;\n        if (state.balance)\n            val += `      balance: ${state.balance}\\n`;\n        if (state.code)\n            val += `      code: ${state.code}\\n`;\n        if (state.state) {\n            val += '      state:\\n';\n            val += prettyStateMapping(state.state);\n        }\n        if (state.stateDiff) {\n            val += '      stateDiff:\\n';\n            val += prettyStateMapping(state.stateDiff);\n        }\n        return val;\n    }, '  State Override:\\n')\n        .slice(0, -1);\n}\n//# sourceMappingURL=stateOverride.js.map","import { formatEther } from '../utils/unit/formatEther.js';\nimport { formatGwei } from '../utils/unit/formatGwei.js';\nimport { BaseError } from './base.js';\nexport function prettyPrint(args) {\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\nexport class FeeConflictError extends BaseError {\n    constructor() {\n        super([\n            'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n            'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n        ].join('\\n'), { name: 'FeeConflictError' });\n    }\n}\nexport class InvalidLegacyVError extends BaseError {\n    constructor({ v }) {\n        super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`, {\n            name: 'InvalidLegacyVError',\n        });\n    }\n}\nexport class InvalidSerializableTransactionError extends BaseError {\n    constructor({ transaction }) {\n        super('Cannot infer a transaction type from provided transaction.', {\n            metaMessages: [\n                'Provided Transaction:',\n                '{',\n                prettyPrint(transaction),\n                '}',\n                '',\n                'To infer the type, either provide:',\n                '- a `type` to the Transaction, or',\n                '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n                '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n                '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',\n                '- an EIP-7702 Transaction with `authorizationList`, or',\n                '- a Legacy Transaction with `gasPrice`',\n            ],\n            name: 'InvalidSerializableTransactionError',\n        });\n    }\n}\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n    constructor({ serializedType }) {\n        super(`Serialized transaction type \"${serializedType}\" is invalid.`, {\n            name: 'InvalidSerializedTransactionType',\n        });\n        Object.defineProperty(this, \"serializedType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.serializedType = serializedType;\n    }\n}\nexport class InvalidSerializedTransactionError extends BaseError {\n    constructor({ attributes, serializedTransaction, type, }) {\n        const missing = Object.entries(attributes)\n            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n            .filter(Boolean);\n        super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n            metaMessages: [\n                `Serialized Transaction: \"${serializedTransaction}\"`,\n                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n            ].filter(Boolean),\n            name: 'InvalidSerializedTransactionError',\n        });\n        Object.defineProperty(this, \"serializedTransaction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.serializedTransaction = serializedTransaction;\n        this.type = type;\n    }\n}\nexport class InvalidStorageKeySizeError extends BaseError {\n    constructor({ storageKey }) {\n        super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: 'InvalidStorageKeySizeError' });\n    }\n}\nexport class TransactionExecutionError extends BaseError {\n    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {\n        const prettyArgs = prettyPrint({\n            chain: chain && `${chain?.name} (id: ${chain?.id})`,\n            from: account?.address,\n            to,\n            value: typeof value !== 'undefined' &&\n                `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n            data,\n            gas,\n            gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&\n                `${formatGwei(maxFeePerGas)} gwei`,\n            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&\n                `${formatGwei(maxPriorityFeePerGas)} gwei`,\n            nonce,\n        });\n        super(cause.shortMessage, {\n            cause,\n            docsPath,\n            metaMessages: [\n                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n                'Request Arguments:',\n                prettyArgs,\n            ].filter(Boolean),\n            name: 'TransactionExecutionError',\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cause = cause;\n    }\n}\nexport class TransactionNotFoundError extends BaseError {\n    constructor({ blockHash, blockNumber, blockTag, hash, index, }) {\n        let identifier = 'Transaction';\n        if (blockTag && index !== undefined)\n            identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`;\n        if (blockHash && index !== undefined)\n            identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`;\n        if (blockNumber && index !== undefined)\n            identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`;\n        if (hash)\n            identifier = `Transaction with hash \"${hash}\"`;\n        super(`${identifier} could not be found.`, {\n            name: 'TransactionNotFoundError',\n        });\n    }\n}\nexport class TransactionReceiptNotFoundError extends BaseError {\n    constructor({ hash }) {\n        super(`Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`, {\n            name: 'TransactionReceiptNotFoundError',\n        });\n    }\n}\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n    constructor({ hash }) {\n        super(`Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`, { name: 'WaitForTransactionReceiptTimeoutError' });\n    }\n}\n//# sourceMappingURL=transaction.js.map","export const getContractAddress = (address) => address;\nexport const getUrl = (url) => url;\n//# sourceMappingURL=utils.js.map","import { InvalidBytesBooleanError } from '../../errors/encoding.js';\nimport { trim } from '../data/trim.js';\nimport { assertSize, hexToBigInt, hexToNumber, } from './fromHex.js';\nimport { bytesToHex } from './toHex.js';\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes(bytes, toOrOpts) {\n    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;\n    const to = opts.to;\n    if (to === 'number')\n        return bytesToNumber(bytes, opts);\n    if (to === 'bigint')\n        return bytesToBigInt(bytes, opts);\n    if (to === 'boolean')\n        return bytesToBool(bytes, opts);\n    if (to === 'string')\n        return bytesToString(bytes, opts);\n    return bytesToHex(bytes, opts);\n}\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(bytes, opts = {}) {\n    if (typeof opts.size !== 'undefined')\n        assertSize(bytes, { size: opts.size });\n    const hex = bytesToHex(bytes, opts);\n    return hexToBigInt(hex, opts);\n}\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(bytes_, opts = {}) {\n    let bytes = bytes_;\n    if (typeof opts.size !== 'undefined') {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes);\n    }\n    if (bytes.length > 1 || bytes[0] > 1)\n        throw new InvalidBytesBooleanError(bytes);\n    return Boolean(bytes[0]);\n}\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(bytes, opts = {}) {\n    if (typeof opts.size !== 'undefined')\n        assertSize(bytes, { size: opts.size });\n    const hex = bytesToHex(bytes, opts);\n    return hexToNumber(hex, opts);\n}\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(bytes_, opts = {}) {\n    let bytes = bytes_;\n    if (typeof opts.size !== 'undefined') {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes, { dir: 'right' });\n    }\n    return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromBytes.js.map","import { AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, InvalidAbiDecodingTypeError, } from '../../errors/abi.js';\nimport { checksumAddress, } from '../address/getAddress.js';\nimport { createCursor, } from '../cursor.js';\nimport { size } from '../data/size.js';\nimport { sliceBytes } from '../data/slice.js';\nimport { trim } from '../data/trim.js';\nimport { bytesToBigInt, bytesToBool, bytesToNumber, bytesToString, } from '../encoding/fromBytes.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nimport { getArrayComponents } from './encodeAbiParameters.js';\nexport function decodeAbiParameters(params, data) {\n    const bytes = typeof data === 'string' ? hexToBytes(data) : data;\n    const cursor = createCursor(bytes);\n    if (size(bytes) === 0 && params.length > 0)\n        throw new AbiDecodingZeroDataError();\n    if (size(data) && size(data) < 32)\n        throw new AbiDecodingDataSizeTooSmallError({\n            data: typeof data === 'string' ? data : bytesToHex(data),\n            params: params,\n            size: size(data),\n        });\n    let consumed = 0;\n    const values = [];\n    for (let i = 0; i < params.length; ++i) {\n        const param = params[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        values.push(data);\n    }\n    return values;\n}\nfunction decodeParameter(cursor, param, { staticPosition }) {\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, { staticPosition });\n    if (param.type === 'address')\n        return decodeAddress(cursor);\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new InvalidAbiDecodingTypeError(param.type, {\n        docsPath: '/docs/contract/decodeAbiParameters',\n    });\n}\n////////////////////////////////////////////////////////////////////\n// Type Decoders\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor) {\n    const value = cursor.readBytes(32);\n    return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];\n}\nfunction decodeArray(cursor, param, { length, staticPosition }) {\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = bytesToNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\nfunction decodeBool(cursor) {\n    return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];\n}\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = bytesToNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = bytesToNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [bytesToHex(data), 32];\n    }\n    const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32));\n    return [value, 32];\n}\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256');\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? bytesToBigInt(value, { signed })\n            : bytesToNumber(value, { signed }),\n        32,\n    ];\n}\nfunction decodeTuple(cursor, param, { staticPosition }) {\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\nfunction decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = bytesToNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = bytesToNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = bytesToString(trim(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({ ...param, type: arrayComponents[1] }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=decodeAbiParameters.js.map","import { solidityError, solidityPanic } from '../../constants/solidity.js';\nimport { AbiDecodingZeroDataError, AbiErrorSignatureNotFoundError, } from '../../errors/abi.js';\nimport { slice } from '../data/slice.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nexport function decodeErrorResult(parameters) {\n    const { abi, data } = parameters;\n    const signature = slice(data, 0, 4);\n    if (signature === '0x')\n        throw new AbiDecodingZeroDataError();\n    const abi_ = [...(abi || []), solidityError, solidityPanic];\n    const abiItem = abi_.find((x) => x.type === 'error' && signature === toFunctionSelector(formatAbiItem(x)));\n    if (!abiItem)\n        throw new AbiErrorSignatureNotFoundError(signature, {\n            docsPath: '/docs/contract/decodeErrorResult',\n        });\n    return {\n        abiItem,\n        args: 'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n            ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n            : undefined,\n        errorName: abiItem.name,\n    };\n}\n//# sourceMappingURL=decodeErrorResult.js.map","import { AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, InvalidAbiEncodingTypeError, InvalidArrayError, } from '../../errors/abi.js';\nimport { InvalidAddressError, } from '../../errors/address.js';\nimport { BaseError } from '../../errors/base.js';\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concat } from '../data/concat.js';\nimport { padHex } from '../data/pad.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { boolToHex, numberToHex, stringToHex, } from '../encoding/toHex.js';\nimport { integerRegex } from '../regex.js';\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters(params, values) {\n    if (params.length !== values.length)\n        throw new AbiEncodingLengthMismatchError({\n            expectedLength: params.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParams = prepareParams({\n        params: params,\n        values: values,\n    });\n    const data = encodeParams(preparedParams);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\nfunction prepareParams({ params, values, }) {\n    const preparedParams = [];\n    for (let i = 0; i < params.length; i++) {\n        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));\n    }\n    return preparedParams;\n}\nfunction prepareParam({ param, value, }) {\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, { length, param: { ...param, type } });\n    }\n    if (param.type === 'tuple') {\n        return encodeTuple(value, {\n            param: param,\n        });\n    }\n    if (param.type === 'address') {\n        return encodeAddress(value);\n    }\n    if (param.type === 'bool') {\n        return encodeBool(value);\n    }\n    if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n        const signed = param.type.startsWith('int');\n        const [, , size = '256'] = integerRegex.exec(param.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (param.type.startsWith('bytes')) {\n        return encodeBytes(value, { param });\n    }\n    if (param.type === 'string') {\n        return encodeString(value);\n    }\n    throw new InvalidAbiEncodingTypeError(param.type, {\n        docsPath: '/docs/contract/encodeAbiParameters',\n    });\n}\nfunction encodeParams(preparedParams) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParams = [];\n    const dynamicParams = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic) {\n            staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n            dynamicParams.push(encoded);\n            dynamicSize += size(encoded);\n        }\n        else {\n            staticParams.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return concat([...staticParams, ...dynamicParams]);\n}\nfunction encodeAddress(value) {\n    if (!isAddress(value))\n        throw new InvalidAddressError({ address: value });\n    return { dynamic: false, encoded: padHex(value.toLowerCase()) };\n}\nfunction encodeArray(value, { length, param, }) {\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiEncodingArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${param.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParams = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParam({ param, value: value[i] });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParams.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encodeParams(preparedParams);\n        if (dynamic) {\n            const length = numberToHex(preparedParams.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nfunction encodeBytes(value, { param }) {\n    const [, paramSize] = param.type.split('bytes');\n    const bytesSize = size(value);\n    if (!paramSize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = padHex(value_, {\n                dir: 'right',\n                size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n            });\n        return {\n            dynamic: true,\n            encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n        };\n    }\n    if (bytesSize !== Number.parseInt(paramSize))\n        throw new AbiEncodingBytesSizeMismatchError({\n            expectedSize: Number.parseInt(paramSize),\n            value,\n        });\n    return { dynamic: false, encoded: padHex(value, { dir: 'right' }) };\n}\nfunction encodeBool(value) {\n    if (typeof value !== 'boolean')\n        throw new BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\nfunction encodeNumber(value, { signed, size = 256 }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: numberToHex(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\nfunction encodeString(value) {\n    const hexValue = stringToHex(value);\n    const partsLength = Math.ceil(size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n            dir: 'right',\n        }));\n    }\n    return {\n        dynamic: true,\n        encoded: concat([\n            padHex(numberToHex(size(hexValue), { size: 32 })),\n            ...parts,\n        ]),\n    };\n}\nfunction encodeTuple(value, { param }) {\n    let dynamic = false;\n    const preparedParams = [];\n    for (let i = 0; i < param.components.length; i++) {\n        const param_ = param.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParam({\n            param: param_,\n            value: value[index],\n        });\n        preparedParams.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encodeParams(preparedParams)\n            : concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nexport function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n//# sourceMappingURL=encodeAbiParameters.js.map","import { InvalidDefinitionTypeError, } from '../../errors/abi.js';\nexport function formatAbiItem(abiItem, { includeName = false } = {}) {\n    if (abiItem.type !== 'function' &&\n        abiItem.type !== 'event' &&\n        abiItem.type !== 'error')\n        throw new InvalidDefinitionTypeError(abiItem.type);\n    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;\n}\nexport function formatAbiParams(params, { includeName = false } = {}) {\n    if (!params)\n        return '';\n    return params\n        .map((param) => formatAbiParam(param, { includeName }))\n        .join(includeName ? ', ' : ',');\n}\nfunction formatAbiParam(param, { includeName }) {\n    if (param.type.startsWith('tuple')) {\n        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;\n    }\n    return param.type + (includeName && param.name ? ` ${param.name}` : '');\n}\n//# sourceMappingURL=formatAbiItem.js.map","import { AbiItemAmbiguityError, } from '../../errors/abi.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nexport function getAbiItem(parameters) {\n    const { abi, args = [], name } = parameters;\n    const isSelector = isHex(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function')\n                return toFunctionSelector(abiItem) === name;\n            if (abiItem.type === 'event')\n                return toEventSelector(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        return undefined;\n    if (abiItems.length === 1)\n        return abiItems[0];\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return abiItem;\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AbiItemAmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    if (matchedAbiItem)\n        return matchedAbiItem;\n    return abiItems[0];\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return isAddress(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return isAddress(args[parameterIndex], { strict: false });\n            if (types.includes('address') && types.includes('bytes'))\n                return isAddress(args[parameterIndex], { strict: false });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=getAbiItem.js.map","import { InvalidAddressError } from '../../errors/address.js';\nimport { stringToBytes, } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { LruMap } from '../lru.js';\nimport { isAddress } from './isAddress.js';\nconst checksumAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function checksumAddress(address_, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (checksumAddressCache.has(`${address_}.${chainId}`))\n        return checksumAddressCache.get(`${address_}.${chainId}`);\n    const hexAddress = chainId\n        ? `${chainId}${address_.toLowerCase()}`\n        : address_.substring(2).toLowerCase();\n    const hash = keccak256(stringToBytes(hexAddress), 'bytes');\n    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n            address[i] = address[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n            address[i + 1] = address[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${address.join('')}`;\n    checksumAddressCache.set(`${address_}.${chainId}`, result);\n    return result;\n}\nexport function getAddress(address, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (!isAddress(address, { strict: false }))\n        throw new InvalidAddressError({ address });\n    return checksumAddress(address, chainId);\n}\n//# sourceMappingURL=getAddress.js.map","import { LruMap } from '../lru.js';\nimport { checksumAddress } from './getAddress.js';\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function isAddress(address, options) {\n    const { strict = true } = options ?? {};\n    const cacheKey = `${address}.${strict}`;\n    if (isAddressCache.has(cacheKey))\n        return isAddressCache.get(cacheKey);\n    const result = (() => {\n        if (!addressRegex.test(address))\n            return false;\n        if (address.toLowerCase() === address)\n            return true;\n        if (strict)\n            return checksumAddress(address) === address;\n        return true;\n    })();\n    isAddressCache.set(cacheKey, result);\n    return result;\n}\n//# sourceMappingURL=isAddress.js.map","import { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments(parameters) {\n    const { kzg } = parameters;\n    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');\n    const blobs = (typeof parameters.blobs[0] === 'string'\n        ? parameters.blobs.map((x) => hexToBytes(x))\n        : parameters.blobs);\n    const commitments = [];\n    for (const blob of blobs)\n        commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));\n    return (to === 'bytes'\n        ? commitments\n        : commitments.map((x) => bytesToHex(x)));\n}\n//# sourceMappingURL=blobsToCommitments.js.map","import { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs(parameters) {\n    const { kzg } = parameters;\n    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');\n    const blobs = (typeof parameters.blobs[0] === 'string'\n        ? parameters.blobs.map((x) => hexToBytes(x))\n        : parameters.blobs);\n    const commitments = (typeof parameters.commitments[0] === 'string'\n        ? parameters.commitments.map((x) => hexToBytes(x))\n        : parameters.commitments);\n    const proofs = [];\n    for (let i = 0; i < blobs.length; i++) {\n        const blob = blobs[i];\n        const commitment = commitments[i];\n        proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\n    }\n    return (to === 'bytes'\n        ? proofs\n        : proofs.map((x) => bytesToHex(x)));\n}\n//# sourceMappingURL=blobsToProofs.js.map","import { bytesToHex } from '../encoding/toHex.js';\nimport { sha256 } from '../hash/sha256.js';\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash(parameters) {\n    const { commitment, version = 1 } = parameters;\n    const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes');\n    const versionedHash = sha256(commitment, 'bytes');\n    versionedHash.set([version], 0);\n    return (to === 'bytes' ? versionedHash : bytesToHex(versionedHash));\n}\n//# sourceMappingURL=commitmentToVersionedHash.js.map","import { commitmentToVersionedHash, } from './commitmentToVersionedHash.js';\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes(parameters) {\n    const { commitments, version } = parameters;\n    const to = parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes');\n    const hashes = [];\n    for (const commitment of commitments) {\n        hashes.push(commitmentToVersionedHash({\n            commitment,\n            to,\n            version,\n        }));\n    }\n    return hashes;\n}\n//# sourceMappingURL=commitmentsToVersionedHashes.js.map","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6;\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32;\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096;\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction -\n    // terminator byte (0x80).\n    1 -\n    // zero byte (0x00) appended to each field element.\n    1 * fieldElementsPerBlob * blobsPerTransaction;\n//# sourceMappingURL=blob.js.map","import { blobsToCommitments, } from './blobsToCommitments.js';\nimport { blobsToProofs } from './blobsToProofs.js';\nimport { toBlobs } from './toBlobs.js';\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars(parameters) {\n    const { data, kzg, to } = parameters;\n    const blobs = parameters.blobs ?? toBlobs({ data: data, to });\n    const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg, to });\n    const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg, to });\n    const sidecars = [];\n    for (let i = 0; i < blobs.length; i++)\n        sidecars.push({\n            blob: blobs[i],\n            commitment: commitments[i],\n            proof: proofs[i],\n        });\n    return sidecars;\n}\n//# sourceMappingURL=toBlobSidecars.js.map","import { bytesPerBlob, bytesPerFieldElement, fieldElementsPerBlob, maxBytesPerTransaction, } from '../../constants/blob.js';\nimport { BlobSizeTooLargeError, EmptyBlobError, } from '../../errors/blob.js';\nimport { createCursor } from '../cursor.js';\nimport { size } from '../data/size.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs(parameters) {\n    const to = parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes');\n    const data = (typeof parameters.data === 'string'\n        ? hexToBytes(parameters.data)\n        : parameters.data);\n    const size_ = size(data);\n    if (!size_)\n        throw new EmptyBlobError();\n    if (size_ > maxBytesPerTransaction)\n        throw new BlobSizeTooLargeError({\n            maxSize: maxBytesPerTransaction,\n            size: size_,\n        });\n    const blobs = [];\n    let active = true;\n    let position = 0;\n    while (active) {\n        const blob = createCursor(new Uint8Array(bytesPerBlob));\n        let size = 0;\n        while (size < fieldElementsPerBlob) {\n            const bytes = data.slice(position, position + (bytesPerFieldElement - 1));\n            // Push a zero byte so the field element doesn't overflow the BLS modulus.\n            blob.pushByte(0x00);\n            // Push the current segment of data bytes.\n            blob.pushBytes(bytes);\n            // If we detect that the current segment of data bytes is less than 31 bytes,\n            // we can stop processing and push a terminator byte to indicate the end of the blob.\n            if (bytes.length < 31) {\n                blob.pushByte(0x80);\n                active = false;\n                break;\n            }\n            size++;\n            position += 31;\n        }\n        blobs.push(blob);\n    }\n    return (to === 'bytes'\n        ? blobs.map((x) => x.bytes)\n        : blobs.map((x) => bytesToHex(x.bytes)));\n}\n//# sourceMappingURL=toBlobs.js.map","export function defineChain(chain) {\n    return {\n        formatters: undefined,\n        fees: undefined,\n        serializers: undefined,\n        ...chain,\n    };\n}\n//# sourceMappingURL=defineChain.js.map","import { NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError, } from '../errors/cursor.js';\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\nexport function createCursor(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n//# sourceMappingURL=cursor.js.map","export function concat(values) {\n    if (typeof values[0] === 'string')\n        return concatHex(values);\n    return concatBytes(values);\n}\nexport function concatBytes(values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const arr of values) {\n        result.set(arr, offset);\n        offset += arr.length;\n    }\n    return result;\n}\nexport function concatHex(values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n//# sourceMappingURL=concat.js.map","import { SliceOffsetOutOfBoundsError, } from '../../errors/data.js';\nimport { isHex } from './isHex.js';\nimport { size } from './size.js';\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice(value, start, end, { strict } = {}) {\n    if (isHex(value, { strict: false }))\n        return sliceHex(value, start, end, {\n            strict,\n        });\n    return sliceBytes(value, start, end, {\n        strict,\n    });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n        throw new SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        size(value) !== end - start) {\n        throw new SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: size(value),\n        });\n    }\n}\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = value_.slice(start, end);\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = `0x${value_\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n//# sourceMappingURL=slice.js.map","import { BaseError } from '../../errors/base.js';\nimport { createCursor, } from '../cursor.js';\nimport { hexToBytes } from './toBytes.js';\nimport { bytesToHex } from './toHex.js';\nexport function toRlp(bytes, to = 'hex') {\n    const encodable = getEncodable(bytes);\n    const cursor = createCursor(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (to === 'hex')\n        return bytesToHex(cursor.bytes);\n    return cursor.bytes;\n}\nexport function bytesToRlp(bytes, to = 'bytes') {\n    return toRlp(bytes, to);\n}\nexport function hexToRlp(hex, to = 'hex') {\n    return toRlp(hex, to);\n}\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length < 2 ** 8)\n        return 1;\n    if (length < 2 ** 16)\n        return 2;\n    if (length < 2 ** 24)\n        return 3;\n    if (length < 2 ** 32)\n        return 4;\n    throw new BaseError('Length is too large.');\n}\n//# sourceMappingURL=toRlp.js.map","import { CallExecutionError, } from '../../errors/contract.js';\nimport { UnknownNodeError } from '../../errors/node.js';\nimport { getNodeError, } from './getNodeError.js';\nexport function getCallError(err, { docsPath, ...args }) {\n    const cause = (() => {\n        const cause = getNodeError(err, args);\n        if (cause instanceof UnknownNodeError)\n            return err;\n        return cause;\n    })();\n    return new CallExecutionError(cause, {\n        docsPath,\n        ...args,\n    });\n}\n//# sourceMappingURL=getCallError.js.map","import { BaseError } from '../../errors/base.js';\nimport { ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, NonceMaxValueError, NonceTooHighError, NonceTooLowError, TipAboveFeeCapError, TransactionTypeNotSupportedError, UnknownNodeError, } from '../../errors/node.js';\nimport { RpcRequestError } from '../../errors/request.js';\nimport { InvalidInputRpcError, TransactionRejectedRpcError, } from '../../errors/rpc.js';\nexport function containsNodeError(err) {\n    return (err instanceof TransactionRejectedRpcError ||\n        err instanceof InvalidInputRpcError ||\n        (err instanceof RpcRequestError && err.code === ExecutionRevertedError.code));\n}\nexport function getNodeError(err, args) {\n    const message = (err.details || '').toLowerCase();\n    const executionRevertedError = err instanceof BaseError\n        ? err.walk((e) => e?.code ===\n            ExecutionRevertedError.code)\n        : err;\n    if (executionRevertedError instanceof BaseError)\n        return new ExecutionRevertedError({\n            cause: err,\n            message: executionRevertedError.details,\n        });\n    if (ExecutionRevertedError.nodeMessage.test(message))\n        return new ExecutionRevertedError({\n            cause: err,\n            message: err.details,\n        });\n    if (FeeCapTooHighError.nodeMessage.test(message))\n        return new FeeCapTooHighError({\n            cause: err,\n            maxFeePerGas: args?.maxFeePerGas,\n        });\n    if (FeeCapTooLowError.nodeMessage.test(message))\n        return new FeeCapTooLowError({\n            cause: err,\n            maxFeePerGas: args?.maxFeePerGas,\n        });\n    if (NonceTooHighError.nodeMessage.test(message))\n        return new NonceTooHighError({ cause: err, nonce: args?.nonce });\n    if (NonceTooLowError.nodeMessage.test(message))\n        return new NonceTooLowError({ cause: err, nonce: args?.nonce });\n    if (NonceMaxValueError.nodeMessage.test(message))\n        return new NonceMaxValueError({ cause: err, nonce: args?.nonce });\n    if (InsufficientFundsError.nodeMessage.test(message))\n        return new InsufficientFundsError({ cause: err });\n    if (IntrinsicGasTooHighError.nodeMessage.test(message))\n        return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });\n    if (IntrinsicGasTooLowError.nodeMessage.test(message))\n        return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });\n    if (TransactionTypeNotSupportedError.nodeMessage.test(message))\n        return new TransactionTypeNotSupportedError({ cause: err });\n    if (TipAboveFeeCapError.nodeMessage.test(message))\n        return new TipAboveFeeCapError({\n            cause: err,\n            maxFeePerGas: args?.maxFeePerGas,\n            maxPriorityFeePerGas: args?.maxPriorityFeePerGas,\n        });\n    return new UnknownNodeError({\n        cause: err,\n    });\n}\n//# sourceMappingURL=getNodeError.js.map","import { defineFormatter } from './formatter.js';\nimport { formatTransaction } from './transaction.js';\nexport function formatBlock(block) {\n    const transactions = (block.transactions ?? []).map((transaction) => {\n        if (typeof transaction === 'string')\n            return transaction;\n        return formatTransaction(transaction);\n    });\n    return {\n        ...block,\n        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n        blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n        difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n        excessBlobGas: block.excessBlobGas\n            ? BigInt(block.excessBlobGas)\n            : undefined,\n        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n        hash: block.hash ? block.hash : null,\n        logsBloom: block.logsBloom ? block.logsBloom : null,\n        nonce: block.nonce ? block.nonce : null,\n        number: block.number ? BigInt(block.number) : null,\n        size: block.size ? BigInt(block.size) : undefined,\n        timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n        transactions,\n        totalDifficulty: block.totalDifficulty\n            ? BigInt(block.totalDifficulty)\n            : null,\n    };\n}\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock);\n//# sourceMappingURL=block.js.map","/**\n * @description Picks out the keys from `value` that exist in the formatter..\n */\nexport function extract(value_, { format }) {\n    if (!format)\n        return {};\n    const value = {};\n    function extract_(formatted) {\n        const keys = Object.keys(formatted);\n        for (const key of keys) {\n            if (key in value_)\n                value[key] = value_[key];\n            if (formatted[key] &&\n                typeof formatted[key] === 'object' &&\n                !Array.isArray(formatted[key]))\n                extract_(formatted[key]);\n        }\n    }\n    const formatted = format(value_ || {});\n    extract_(formatted);\n    return value;\n}\n//# sourceMappingURL=extract.js.map","export function defineFormatter(type, format) {\n    return ({ exclude, format: overrides, }) => {\n        return {\n            exclude,\n            format: (args) => {\n                const formatted = format(args);\n                if (exclude) {\n                    for (const key of exclude) {\n                        delete formatted[key];\n                    }\n                }\n                return {\n                    ...formatted,\n                    ...overrides(args),\n                };\n            },\n            type,\n        };\n    };\n}\n//# sourceMappingURL=formatter.js.map","export function formatLog(log, { args, eventName, } = {}) {\n    return {\n        ...log,\n        blockHash: log.blockHash ? log.blockHash : null,\n        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n        logIndex: log.logIndex ? Number(log.logIndex) : null,\n        transactionHash: log.transactionHash ? log.transactionHash : null,\n        transactionIndex: log.transactionIndex\n            ? Number(log.transactionIndex)\n            : null,\n        ...(eventName ? { args, eventName } : {}),\n    };\n}\n//# sourceMappingURL=log.js.map","import { hexToNumber } from '../encoding/fromHex.js';\nimport { defineFormatter } from './formatter.js';\nexport const transactionType = {\n    '0x0': 'legacy',\n    '0x1': 'eip2930',\n    '0x2': 'eip1559',\n    '0x3': 'eip4844',\n    '0x4': 'eip7702',\n};\nexport function formatTransaction(transaction) {\n    const transaction_ = {\n        ...transaction,\n        blockHash: transaction.blockHash ? transaction.blockHash : null,\n        blockNumber: transaction.blockNumber\n            ? BigInt(transaction.blockNumber)\n            : null,\n        chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n        gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n        maxFeePerBlobGas: transaction.maxFeePerBlobGas\n            ? BigInt(transaction.maxFeePerBlobGas)\n            : undefined,\n        maxFeePerGas: transaction.maxFeePerGas\n            ? BigInt(transaction.maxFeePerGas)\n            : undefined,\n        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n            ? BigInt(transaction.maxPriorityFeePerGas)\n            : undefined,\n        nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n        to: transaction.to ? transaction.to : null,\n        transactionIndex: transaction.transactionIndex\n            ? Number(transaction.transactionIndex)\n            : null,\n        type: transaction.type\n            ? transactionType[transaction.type]\n            : undefined,\n        typeHex: transaction.type ? transaction.type : undefined,\n        value: transaction.value ? BigInt(transaction.value) : undefined,\n        v: transaction.v ? BigInt(transaction.v) : undefined,\n    };\n    if (transaction.authorizationList)\n        transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);\n    transaction_.yParity = (() => {\n        // If `yParity` is provided, we will use it.\n        if (transaction.yParity)\n            return Number(transaction.yParity);\n        // If no `yParity` provided, try derive from `v`.\n        if (typeof transaction_.v === 'bigint') {\n            if (transaction_.v === 0n || transaction_.v === 27n)\n                return 0;\n            if (transaction_.v === 1n || transaction_.v === 28n)\n                return 1;\n            if (transaction_.v >= 35n)\n                return transaction_.v % 2n === 0n ? 1 : 0;\n        }\n        return undefined;\n    })();\n    if (transaction_.type === 'legacy') {\n        delete transaction_.accessList;\n        delete transaction_.maxFeePerBlobGas;\n        delete transaction_.maxFeePerGas;\n        delete transaction_.maxPriorityFeePerGas;\n        delete transaction_.yParity;\n    }\n    if (transaction_.type === 'eip2930') {\n        delete transaction_.maxFeePerBlobGas;\n        delete transaction_.maxFeePerGas;\n        delete transaction_.maxPriorityFeePerGas;\n    }\n    if (transaction_.type === 'eip1559') {\n        delete transaction_.maxFeePerBlobGas;\n    }\n    return transaction_;\n}\nexport const defineTransaction = /*#__PURE__*/ defineFormatter('transaction', formatTransaction);\n//////////////////////////////////////////////////////////////////////////////\nfunction formatAuthorizationList(authorizationList) {\n    return authorizationList.map((authorization) => ({\n        contractAddress: authorization.address,\n        chainId: Number(authorization.chainId),\n        nonce: Number(authorization.nonce),\n        r: authorization.r,\n        s: authorization.s,\n        yParity: Number(authorization.yParity),\n    }));\n}\n//# sourceMappingURL=transaction.js.map","import { hexToNumber } from '../encoding/fromHex.js';\nimport { defineFormatter } from './formatter.js';\nimport { formatLog } from './log.js';\nimport { transactionType } from './transaction.js';\nexport const receiptStatuses = {\n    '0x0': 'reverted',\n    '0x1': 'success',\n};\nexport function formatTransactionReceipt(transactionReceipt) {\n    const receipt = {\n        ...transactionReceipt,\n        blockNumber: transactionReceipt.blockNumber\n            ? BigInt(transactionReceipt.blockNumber)\n            : null,\n        contractAddress: transactionReceipt.contractAddress\n            ? transactionReceipt.contractAddress\n            : null,\n        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n            ? BigInt(transactionReceipt.cumulativeGasUsed)\n            : null,\n        effectiveGasPrice: transactionReceipt.effectiveGasPrice\n            ? BigInt(transactionReceipt.effectiveGasPrice)\n            : null,\n        gasUsed: transactionReceipt.gasUsed\n            ? BigInt(transactionReceipt.gasUsed)\n            : null,\n        logs: transactionReceipt.logs\n            ? transactionReceipt.logs.map((log) => formatLog(log))\n            : null,\n        to: transactionReceipt.to ? transactionReceipt.to : null,\n        transactionIndex: transactionReceipt.transactionIndex\n            ? hexToNumber(transactionReceipt.transactionIndex)\n            : null,\n        status: transactionReceipt.status\n            ? receiptStatuses[transactionReceipt.status]\n            : null,\n        type: transactionReceipt.type\n            ? transactionType[transactionReceipt.type] || transactionReceipt.type\n            : null,\n    };\n    if (transactionReceipt.blobGasPrice)\n        receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n    if (transactionReceipt.blobGasUsed)\n        receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n    return receipt;\n}\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter('transactionReceipt', formatTransactionReceipt);\n//# sourceMappingURL=transactionReceipt.js.map","import { bytesToHex, numberToHex } from '../encoding/toHex.js';\nimport { defineFormatter } from './formatter.js';\nexport const rpcTransactionType = {\n    legacy: '0x0',\n    eip2930: '0x1',\n    eip1559: '0x2',\n    eip4844: '0x3',\n    eip7702: '0x4',\n};\nexport function formatTransactionRequest(request) {\n    const rpcRequest = {};\n    if (typeof request.authorizationList !== 'undefined')\n        rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);\n    if (typeof request.accessList !== 'undefined')\n        rpcRequest.accessList = request.accessList;\n    if (typeof request.blobVersionedHashes !== 'undefined')\n        rpcRequest.blobVersionedHashes = request.blobVersionedHashes;\n    if (typeof request.blobs !== 'undefined') {\n        if (typeof request.blobs[0] !== 'string')\n            rpcRequest.blobs = request.blobs.map((x) => bytesToHex(x));\n        else\n            rpcRequest.blobs = request.blobs;\n    }\n    if (typeof request.data !== 'undefined')\n        rpcRequest.data = request.data;\n    if (typeof request.from !== 'undefined')\n        rpcRequest.from = request.from;\n    if (typeof request.gas !== 'undefined')\n        rpcRequest.gas = numberToHex(request.gas);\n    if (typeof request.gasPrice !== 'undefined')\n        rpcRequest.gasPrice = numberToHex(request.gasPrice);\n    if (typeof request.maxFeePerBlobGas !== 'undefined')\n        rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);\n    if (typeof request.maxFeePerGas !== 'undefined')\n        rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== 'undefined')\n        rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);\n    if (typeof request.nonce !== 'undefined')\n        rpcRequest.nonce = numberToHex(request.nonce);\n    if (typeof request.to !== 'undefined')\n        rpcRequest.to = request.to;\n    if (typeof request.type !== 'undefined')\n        rpcRequest.type = rpcTransactionType[request.type];\n    if (typeof request.value !== 'undefined')\n        rpcRequest.value = numberToHex(request.value);\n    return rpcRequest;\n}\nexport const defineTransactionRequest = /*#__PURE__*/ defineFormatter('transactionRequest', formatTransactionRequest);\n//////////////////////////////////////////////////////////////////////////////\nfunction formatAuthorizationList(authorizationList) {\n    return authorizationList.map((authorization) => ({\n        address: authorization.contractAddress,\n        r: authorization.r,\n        s: authorization.s,\n        chainId: numberToHex(authorization.chainId),\n        nonce: numberToHex(authorization.nonce),\n        ...(typeof authorization.yParity !== 'undefined'\n            ? { yParity: numberToHex(authorization.yParity) }\n            : {}),\n        ...(typeof authorization.v !== 'undefined' &&\n            typeof authorization.yParity === 'undefined'\n            ? { v: numberToHex(authorization.v) }\n            : {}),\n    }));\n}\n//# sourceMappingURL=transactionRequest.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { abytes, aexists, anumber, aoutput } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","import { keccak_256 } from '@noble/hashes/sha3';\nimport { isHex } from '../data/isHex.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toHex } from '../encoding/toHex.js';\nexport function keccak256(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return toHex(bytes);\n}\n//# sourceMappingURL=keccak256.js.map","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { sha256 as noble_sha256 } from '@noble/hashes/sha256';\nimport { isHex } from '../data/isHex.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toHex } from '../encoding/toHex.js';\nexport function sha256(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = noble_sha256(isHex(value, { strict: false }) ? toBytes(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return toHex(bytes);\n}\n//# sourceMappingURL=sha256.js.map","import { toSignatureHash, } from './toSignatureHash.js';\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash;\n//# sourceMappingURL=toEventSelector.js.map","import { slice } from '../data/slice.js';\nimport { toSignatureHash, } from './toSignatureHash.js';\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);\n//# sourceMappingURL=toFunctionSelector.js.map","import { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from './keccak256.js';\nconst hash = (value) => keccak256(toBytes(value));\nexport function hashSignature(sig) {\n    return hash(sig);\n}\n//# sourceMappingURL=hashSignature.js.map","import { execTyped } from '../regex.js';\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter(abiParameter) {\n    let type = abiParameter.type;\n    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n        type = '(';\n        const length = abiParameter.components.length;\n        for (let i = 0; i < length; i++) {\n            const component = abiParameter.components[i];\n            type += formatAbiParameter(component);\n            if (i < length - 1)\n                type += ', ';\n        }\n        const result = execTyped(tupleRegex, abiParameter.type);\n        type += `)${result?.array ?? ''}`;\n        return formatAbiParameter({\n            ...abiParameter,\n            type,\n        });\n    }\n    // Add `indexed` to type if in `abiParameter`\n    if ('indexed' in abiParameter && abiParameter.indexed)\n        type = `${type} indexed`;\n    // Return human-readable ABI parameter\n    if (abiParameter.name)\n        return `${type} ${abiParameter.name}`;\n    return type;\n}\n//# sourceMappingURL=formatAbiParameter.js.map","import { formatAbiParameter, } from './formatAbiParameter.js';\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters(abiParameters) {\n    let params = '';\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        params += formatAbiParameter(abiParameter);\n        if (i !== length - 1)\n            params += ', ';\n    }\n    return params;\n}\n//# sourceMappingURL=formatAbiParameters.js.map","import { formatAbiItem } from 'abitype';\nimport { normalizeSignature, } from './normalizeSignature.js';\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def) => {\n    const def_ = (() => {\n        if (typeof def === 'string')\n            return def;\n        return formatAbiItem(def);\n    })();\n    return normalizeSignature(def_);\n};\n//# sourceMappingURL=toSignature.js.map","import { formatAbiParameters, } from './formatAbiParameters.js';\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem(abiItem) {\n    if (abiItem.type === 'function')\n        return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n            ? ` ${abiItem.stateMutability}`\n            : ''}${abiItem.outputs?.length\n            ? ` returns (${formatAbiParameters(abiItem.outputs)})`\n            : ''}`;\n    if (abiItem.type === 'event')\n        return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'error')\n        return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'constructor')\n        return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    if (abiItem.type === 'fallback')\n        return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    return 'receive() external payable';\n}\n//# sourceMappingURL=formatAbiItem.js.map","import { BaseError } from '../../errors/base.js';\nexport function normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new BaseError('Unable to normalize signature.');\n    return result;\n}\n//# sourceMappingURL=normalizeSignature.js.map","import { hashSignature } from './hashSignature.js';\nimport { toSignature } from './toSignature.js';\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn) {\n    return hashSignature(toSignature(fn));\n}\n//# sourceMappingURL=toSignatureHash.js.map","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\n//# sourceMappingURL=regex.js.map","export const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {\n    const value = typeof value_ === 'bigint' ? value_.toString() : value_;\n    return typeof replacer === 'function' ? replacer(key, value) : value;\n}, space);\n//# sourceMappingURL=stringify.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { maxUint256 } from '../../constants/number.js';\nimport { InvalidAddressError, } from '../../errors/address.js';\nimport { FeeCapTooHighError, TipAboveFeeCapError, } from '../../errors/node.js';\nimport { FeeConflictError, } from '../../errors/transaction.js';\nimport { isAddress } from '../address/isAddress.js';\nexport function assertRequest(args) {\n    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to, } = args;\n    const account = account_ ? parseAccount(account_) : undefined;\n    if (account && !isAddress(account.address))\n        throw new InvalidAddressError({ address: account.address });\n    if (to && !isAddress(to))\n        throw new InvalidAddressError({ address: to });\n    if (typeof gasPrice !== 'undefined' &&\n        (typeof maxFeePerGas !== 'undefined' ||\n            typeof maxPriorityFeePerGas !== 'undefined'))\n        throw new FeeConflictError();\n    if (maxFeePerGas && maxFeePerGas > maxUint256)\n        throw new FeeCapTooHighError({ maxFeePerGas });\n    if (maxPriorityFeePerGas &&\n        maxFeePerGas &&\n        maxPriorityFeePerGas > maxFeePerGas)\n        throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });\n}\n//# sourceMappingURL=assertRequest.js.map","import { InvalidSerializableTransactionError, } from '../../errors/transaction.js';\nexport function getTransactionType(transaction) {\n    if (transaction.type)\n        return transaction.type;\n    if (typeof transaction.authorizationList !== 'undefined')\n        return 'eip7702';\n    if (typeof transaction.blobs !== 'undefined' ||\n        typeof transaction.blobVersionedHashes !== 'undefined' ||\n        typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n        typeof transaction.sidecars !== 'undefined')\n        return 'eip4844';\n    if (typeof transaction.maxFeePerGas !== 'undefined' ||\n        typeof transaction.maxPriorityFeePerGas !== 'undefined') {\n        return 'eip1559';\n    }\n    if (typeof transaction.gasPrice !== 'undefined') {\n        if (typeof transaction.accessList !== 'undefined')\n            return 'eip2930';\n        return 'legacy';\n    }\n    throw new InvalidSerializableTransactionError({ transaction });\n}\n//# sourceMappingURL=getTransactionType.js.map","import { gweiUnits } from '../../constants/unit.js';\nimport { formatUnits } from './formatUnits.js';\n/**\n * Converts numerical wei to a string representation of gwei.\n *\n * - Docs: https://viem.sh/docs/utilities/formatGwei\n *\n * @example\n * import { formatGwei } from 'viem'\n *\n * formatGwei(1000000000n)\n * // '1'\n */\nexport function formatGwei(wei, unit = 'wei') {\n    return formatUnits(wei, gweiUnits[unit]);\n}\n//# sourceMappingURL=formatGwei.js.map"],"names":["anumber","n","Number","isSafeInteger","Error","abytes","b","lengths","a","Uint8Array","ArrayBuffer","isView","constructor","name","length","includes","aexists","instance","checkFinished","destroyed","finished","aoutput","out","min","outputLen","u32","arr","Uint32Array","buffer","byteOffset","Math","floor","byteLength","createView","DataView","rotr","word","shift","isLE","byteSwap","byteSwap32","i","toBytes","data","str","TextEncoder","encode","utf8ToBytes","Hash","clone","this","_cloneInto","wrapConstructor","hashCons","hashC","msg","update","digest","tmp","blockLen","create","execTyped","regex","string","match","exec","groups","bytesRegex","integerRegex","isTupleRegex","parseAccount","account","address","type","versionedHashVersionKzg","maxUint16","maxUint256","panicReasons","solidityError","inputs","solidityPanic","AbiConstructorNotFoundError","docsPath","super","join","AbiConstructorParamsNotFoundError","AbiDecodingDataSizeTooSmallError","params","size","metaMessages","includeName","Object","defineProperty","enumerable","configurable","writable","value","AbiDecodingZeroDataError","AbiEncodingArrayLengthMismatchError","expectedLength","givenLength","AbiEncodingBytesSizeMismatchError","expectedSize","AbiEncodingLengthMismatchError","AbiErrorSignatureNotFoundError","signature","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","AbiEventNotFoundError","eventName","AbiFunctionNotFoundError","functionName","AbiFunctionOutputsNotFoundError","AbiItemAmbiguityError","x","y","abiItem","BytesSizeMismatchError","givenSize","DecodeLogDataMismatch","DecodeLogTopicsMismatch","param","InvalidAbiEncodingTypeError","InvalidAbiDecodingTypeError","InvalidArrayError","InvalidDefinitionTypeError","InvalidAddressError","BlobSizeTooLargeError","maxSize","EmptyBlobError","InvalidVersionedHashSizeError","hash","InvalidVersionedHashVersionError","version","ChainDoesNotSupportContract","blockNumber","chain","contract","blockCreated","ClientChainNotConfiguredError","InvalidChainIdError","chainId","formatAbiItemWithArgs","args","includeFunctionName","map","input","stringify","CallExecutionError","cause","account_","gas","gasPrice","maxFeePerGas","maxPriorityFeePerGas","nonce","to","stateOverride","undefined","prettyArgs","from","formatEther","nativeCurrency","symbol","formatGwei","shortMessage","filter","Boolean","ContractFunctionExecutionError","abi","contractAddress","sender","getAbiItem","formattedArgs","functionWithParams","formatAbiItem","function","Array","keys","ContractFunctionRevertedError","message","decodedData","reason","decodeErrorResult","errorName","errorArgs","firstArg","errorWithParams","err","ContractFunctionZeroDataError","CounterfactualDeploymentFailedError","factory","RawContractError","NegativeOffsetError","offset","PositionOutOfBoundsError","position","RecursiveReadLimitExceededError","count","limit","ExecutionRevertedError","replace","FeeCapTooHighError","FeeCapTooLowError","NonceTooHighError","NonceTooLowError","NonceMaxValueError","InsufficientFundsError","IntrinsicGasTooHighError","IntrinsicGasTooLowError","TransactionTypeNotSupportedError","TipAboveFeeCapError","UnknownNodeError","AccountStateConflictError","StateAssignmentConflictError","prettyStateMapping","stateMapping","reduce","pretty","slot","prettyStateOverride","state","val","balance","code","stateDiff","slice","prettyPrint","entries","key","maxLength","acc","max","padEnd","FeeConflictError","InvalidLegacyVError","v","InvalidSerializableTransactionError","transaction","InvalidStorageKeySizeError","storageKey","TransactionNotFoundError","blockHash","blockTag","index","identifier","TransactionReceiptNotFoundError","WaitForTransactionReceiptTimeoutError","getContractAddress","getUrl","url","bytesToBigInt","bytes","opts","hex","bytesToBool","bytes_","trim","bytesToNumber","bytesToString","dir","TextDecoder","decode","decodeAbiParameters","cursor","consumed","values","setPosition","consumed_","decodeParameter","staticPosition","push","arrayComponents","start","readBytes","sizeOfOffset","startOfData","sizeOfLength","dynamicChild","hasDynamicChild","decodeArray","hasUnnamedChild","components","some","component","decodeTuple","decodeAddress","decodeBool","startsWith","_","split","parseInt","decodeBytes","signed","decodeNumber","decodeString","endsWith","parameters","find","encodeAbiParameters","preparedParams","prepareParam","prepareParams","encodeParams","getArrayComponents","dynamic","isArray","preparedParam","encoded","encodeArray","param_","encodeTuple","toLowerCase","encodeAddress","encodeBool","BigInt","toString","encodeNumber","paramSize","bytesSize","value_","ceil","encodeBytes","hexValue","partsLength","parts","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","matches","formatAbiParams","formatAbiParam","isSelector","strict","abiItems","matchedAbiItem","every","arg","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","argType","abiParameterType","test","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","checksumAddressCache","checksumAddress","address_","has","get","hexAddress","substring","toUpperCase","result","set","getAddress","addressRegex","isAddressCache","isAddress","options","cacheKey","blobsToCommitments","kzg","blobs","commitments","blob","blobToKzgCommitment","blobsToProofs","proofs","commitment","computeBlobKzgProof","commitmentToVersionedHash","versionedHash","sha256","commitmentsToVersionedHashes","hashes","bytesPerFieldElement","fieldElementsPerBlob","bytesPerBlob","maxBytesPerTransaction","toBlobSidecars","size_","active","pushByte","pushBytes","toBlobs","sidecars","proof","defineChain","formatters","fees","serializers","staticCursor","dataView","positionReadCount","Map","recursiveReadCount","recursiveReadLimit","POSITIVE_INFINITY","assertReadLimit","assertPosition","decrementPosition","getReadCount","incrementPosition","inspectByte","position_","inspectBytes","subarray","inspectUint8","inspectUint16","getUint16","inspectUint24","getUint8","inspectUint32","getUint32","byte","pushUint8","pushUint16","setUint16","pushUint24","setUint8","pushUint32","setUint32","readByte","_touch","readUint8","readUint16","readUint24","readUint32","remaining","oldPosition","createCursor","concat","concatHex","concatBytes","end","sliceHex","sliceBytes","assertStartOffset","assertEndOffset","toRlp","encodable","getEncodable","list","bodyLength","sizeOfBodyLength","getSizeOfLength","getEncodableList","bytesOrHex","sizeOfBytesLength","getEncodableBytes","getCallError","getNodeError","details","executionRevertedError","walk","e","nodeMessage","formatBlock","block","transactions","baseFeePerGas","blobGasUsed","difficulty","excessBlobGas","gasLimit","gasUsed","logsBloom","number","timestamp","totalDifficulty","defineBlock","extract","format","extract_","formatted","defineFormatter","exclude","overrides","formatLog","log","logIndex","transactionHash","transactionIndex","transactionType","formatTransaction","transaction_","maxFeePerBlobGas","typeHex","authorizationList","authorization","r","s","yParity","accessList","defineTransaction","receiptStatuses","formatTransactionReceipt","transactionReceipt","receipt","cumulativeGasUsed","effectiveGasPrice","logs","status","blobGasPrice","defineTransactionReceipt","rpcTransactionType","legacy","eip2930","eip1559","eip4844","eip7702","formatTransactionRequest","request","rpcRequest","blobVersionedHashes","defineTransactionRequest","U32_MASK64","_32n","fromBig","le","h","l","lst","Ah","Al","rotlSH","rotlSL","rotlBH","rotlBL","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","t","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","suffix","enableXOF","rounds","pos","posOut","state32","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","fill","keccakP","len","take","finish","writeInto","bufferOut","xofInto","xof","digestInto","destroy","gen","keccak_256","keccak256","to_","isHex","toHex","Maj","c","HashMD","padOffset","view","process","roundClean","setBigUint64","_u32_max","wh","wl","oview","outLen","res","SHA256_K","SHA256_IV","SHA256_W","SHA256","A","C","D","E","F","G","H","W15","W2","s0","s1","T1","T2","toEventSelector","toFunctionSelector","fn","tupleRegex","formatAbiParameter","array","indexed","formatAbiParameters","abiParameters","toSignature","def","current","level","valid","char","normalizeSignature","stateMutability","outputs","toSignatureHash","sig","LruMap","delete","firstKey","next","replacer","space","JSON","assertRequest","getTransactionType","wei","unit"],"sourceRoot":""}