{"version":3,"file":"chunk/4691.daa8536b.js","mappings":"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","sources":["webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/_assert.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/utils.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/regex.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/abi.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/address.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/encodeAbiParameters.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/formatAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/abi/getAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/address/getAddress.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/address/isAddress.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/concat.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/slice.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/_u64.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/sha3.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/keccak256.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toEventSelector.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toFunctionSelector.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/hashSignature.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toSignature.js","webpack://@snx-v3/liquidity/../../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/normalizeSignature.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/toSignatureHash.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/lru.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/regex.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/stringify.js"],"sourcesContent":["function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\nconst assert = {\n    number: anumber,\n    bytes: abytes,\n    hash: ahash,\n    exists: aexists,\n    output: aoutput,\n};\nexport default assert;\n//# sourceMappingURL=_assert.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map","import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js';\nimport { size } from '../utils/data/size.js';\nimport { BaseError } from './base.js';\nexport class AbiConstructorNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'A constructor was not found on the ABI.',\n            'Make sure you are using the correct ABI and that the constructor exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiConstructorNotFoundError',\n        });\n    }\n}\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiConstructorParamsNotFoundError',\n        });\n    }\n}\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n    constructor({ data, size }) {\n        super([\n            `Data size of ${size} bytes is invalid.`,\n            'Size must be in increments of 32 bytes (size % 32 === 0).',\n        ].join('\\n'), {\n            metaMessages: [`Data: ${data} (${size} bytes)`],\n            name: 'AbiDecodingDataSizeInvalidError',\n        });\n    }\n}\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n    constructor({ data, params, size, }) {\n        super([`Data size of ${size} bytes is too small for given parameters.`].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n            name: 'AbiDecodingDataSizeTooSmallError',\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n            name: 'AbiDecodingZeroDataError',\n        });\n    }\n}\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super([\n            `ABI encoding array length mismatch for type ${type}.`,\n            `Expected length: ${expectedLength}`,\n            `Given length: ${givenLength}`,\n        ].join('\\n'), { name: 'AbiEncodingArrayLengthMismatchError' });\n    }\n}\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, value }) {\n        super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: 'AbiEncodingBytesSizeMismatchError' });\n    }\n}\nexport class AbiEncodingLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding params/values length mismatch.',\n            `Expected length (params): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'), { name: 'AbiEncodingLengthMismatchError' });\n    }\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n    constructor(errorName, { docsPath }) {\n        super([\n            `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n            'Cannot encode error result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the inputs exist on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorInputsNotFoundError',\n        });\n    }\n}\nexport class AbiErrorNotFoundError extends BaseError {\n    constructor(errorName, { docsPath } = {}) {\n        super([\n            `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorNotFoundError',\n        });\n    }\n}\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded error signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorSignatureNotFoundError',\n        });\n        Object.defineProperty(this, \"signature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.signature = signature;\n    }\n}\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n    constructor({ docsPath }) {\n        super('Cannot extract event signature from empty topics.', {\n            docsPath,\n            name: 'AbiEventSignatureEmptyTopicsError',\n        });\n    }\n}\nexport class AbiEventSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded event signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiEventSignatureNotFoundError',\n        });\n    }\n}\nexport class AbiEventNotFoundError extends BaseError {\n    constructor(eventName, { docsPath } = {}) {\n        super([\n            `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiEventNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n    constructor(functionName, { docsPath } = {}) {\n        super([\n            `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n    constructor(functionName, { docsPath }) {\n        super([\n            `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n            'Cannot decode function result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionOutputsNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded function signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionSignatureNotFoundError',\n        });\n    }\n}\nexport class AbiItemAmbiguityError extends BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI items.', {\n            metaMessages: [\n                `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n                `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n            name: 'AbiItemAmbiguityError',\n        });\n    }\n}\nexport class BytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, givenSize, }) {\n        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n            name: 'BytesSizeMismatchError',\n        });\n    }\n}\nexport class DecodeLogDataMismatch extends BaseError {\n    constructor({ abiItem, data, params, size, }) {\n        super([\n            `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n        ].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n            name: 'DecodeLogDataMismatch',\n        });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n    constructor({ abiItem, param, }) {\n        super([\n            `Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : ''} on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n        ].join('\\n'), { name: 'DecodeLogTopicsMismatch' });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n    }\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid encoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath, name: 'InvalidAbiEncodingType' });\n    }\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid decoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath, name: 'InvalidAbiDecodingType' });\n    }\n}\nexport class InvalidArrayError extends BaseError {\n    constructor(value) {\n        super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n            name: 'InvalidArrayError',\n        });\n    }\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n    constructor(type) {\n        super([\n            `\"${type}\" is not a valid definition type.`,\n            'Valid types: \"function\", \"event\", \"error\"',\n        ].join('\\n'), { name: 'InvalidDefinitionTypeError' });\n    }\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n    constructor(type) {\n        super(`Type \"${type}\" is not supported for packed encoding.`, {\n            name: 'UnsupportedPackedAbiType',\n        });\n    }\n}\n//# sourceMappingURL=abi.js.map","import { BaseError } from './base.js';\nexport class InvalidAddressError extends BaseError {\n    constructor({ address }) {\n        super(`Address \"${address}\" is invalid.`, {\n            metaMessages: [\n                '- Address must be a hex value of 20 bytes (40 hex characters).',\n                '- Address must match its checksum counterpart.',\n            ],\n            name: 'InvalidAddressError',\n        });\n    }\n}\n//# sourceMappingURL=address.js.map","import { AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, InvalidAbiEncodingTypeError, InvalidArrayError, } from '../../errors/abi.js';\nimport { InvalidAddressError, } from '../../errors/address.js';\nimport { BaseError } from '../../errors/base.js';\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concat } from '../data/concat.js';\nimport { padHex } from '../data/pad.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { boolToHex, numberToHex, stringToHex, } from '../encoding/toHex.js';\nimport { integerRegex } from '../regex.js';\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters(params, values) {\n    if (params.length !== values.length)\n        throw new AbiEncodingLengthMismatchError({\n            expectedLength: params.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParams = prepareParams({\n        params: params,\n        values: values,\n    });\n    const data = encodeParams(preparedParams);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\nfunction prepareParams({ params, values, }) {\n    const preparedParams = [];\n    for (let i = 0; i < params.length; i++) {\n        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));\n    }\n    return preparedParams;\n}\nfunction prepareParam({ param, value, }) {\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, { length, param: { ...param, type } });\n    }\n    if (param.type === 'tuple') {\n        return encodeTuple(value, {\n            param: param,\n        });\n    }\n    if (param.type === 'address') {\n        return encodeAddress(value);\n    }\n    if (param.type === 'bool') {\n        return encodeBool(value);\n    }\n    if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n        const signed = param.type.startsWith('int');\n        const [, , size = '256'] = integerRegex.exec(param.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (param.type.startsWith('bytes')) {\n        return encodeBytes(value, { param });\n    }\n    if (param.type === 'string') {\n        return encodeString(value);\n    }\n    throw new InvalidAbiEncodingTypeError(param.type, {\n        docsPath: '/docs/contract/encodeAbiParameters',\n    });\n}\nfunction encodeParams(preparedParams) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParams = [];\n    const dynamicParams = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic) {\n            staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n            dynamicParams.push(encoded);\n            dynamicSize += size(encoded);\n        }\n        else {\n            staticParams.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return concat([...staticParams, ...dynamicParams]);\n}\nfunction encodeAddress(value) {\n    if (!isAddress(value))\n        throw new InvalidAddressError({ address: value });\n    return { dynamic: false, encoded: padHex(value.toLowerCase()) };\n}\nfunction encodeArray(value, { length, param, }) {\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiEncodingArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${param.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParams = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParam({ param, value: value[i] });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParams.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encodeParams(preparedParams);\n        if (dynamic) {\n            const length = numberToHex(preparedParams.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nfunction encodeBytes(value, { param }) {\n    const [, paramSize] = param.type.split('bytes');\n    const bytesSize = size(value);\n    if (!paramSize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = padHex(value_, {\n                dir: 'right',\n                size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n            });\n        return {\n            dynamic: true,\n            encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n        };\n    }\n    if (bytesSize !== Number.parseInt(paramSize))\n        throw new AbiEncodingBytesSizeMismatchError({\n            expectedSize: Number.parseInt(paramSize),\n            value,\n        });\n    return { dynamic: false, encoded: padHex(value, { dir: 'right' }) };\n}\nfunction encodeBool(value) {\n    if (typeof value !== 'boolean')\n        throw new BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\nfunction encodeNumber(value, { signed, size = 256 }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: numberToHex(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\nfunction encodeString(value) {\n    const hexValue = stringToHex(value);\n    const partsLength = Math.ceil(size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n            dir: 'right',\n        }));\n    }\n    return {\n        dynamic: true,\n        encoded: concat([\n            padHex(numberToHex(size(hexValue), { size: 32 })),\n            ...parts,\n        ]),\n    };\n}\nfunction encodeTuple(value, { param }) {\n    let dynamic = false;\n    const preparedParams = [];\n    for (let i = 0; i < param.components.length; i++) {\n        const param_ = param.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParam({\n            param: param_,\n            value: value[index],\n        });\n        preparedParams.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encodeParams(preparedParams)\n            : concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nexport function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n//# sourceMappingURL=encodeAbiParameters.js.map","import { InvalidDefinitionTypeError, } from '../../errors/abi.js';\nexport function formatAbiItem(abiItem, { includeName = false } = {}) {\n    if (abiItem.type !== 'function' &&\n        abiItem.type !== 'event' &&\n        abiItem.type !== 'error')\n        throw new InvalidDefinitionTypeError(abiItem.type);\n    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;\n}\nexport function formatAbiParams(params, { includeName = false } = {}) {\n    if (!params)\n        return '';\n    return params\n        .map((param) => formatAbiParam(param, { includeName }))\n        .join(includeName ? ', ' : ',');\n}\nfunction formatAbiParam(param, { includeName }) {\n    if (param.type.startsWith('tuple')) {\n        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;\n    }\n    return param.type + (includeName && param.name ? ` ${param.name}` : '');\n}\n//# sourceMappingURL=formatAbiItem.js.map","import { AbiItemAmbiguityError, } from '../../errors/abi.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nexport function getAbiItem(parameters) {\n    const { abi, args = [], name } = parameters;\n    const isSelector = isHex(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function')\n                return toFunctionSelector(abiItem) === name;\n            if (abiItem.type === 'event')\n                return toEventSelector(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        return undefined;\n    if (abiItems.length === 1)\n        return abiItems[0];\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return abiItem;\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AbiItemAmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    if (matchedAbiItem)\n        return matchedAbiItem;\n    return abiItems[0];\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return isAddress(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return isAddress(args[parameterIndex], { strict: false });\n            if (types.includes('address') && types.includes('bytes'))\n                return isAddress(args[parameterIndex], { strict: false });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=getAbiItem.js.map","import { InvalidAddressError } from '../../errors/address.js';\nimport { stringToBytes, } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { LruMap } from '../lru.js';\nimport { isAddress } from './isAddress.js';\nconst checksumAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function checksumAddress(address_, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (checksumAddressCache.has(`${address_}.${chainId}`))\n        return checksumAddressCache.get(`${address_}.${chainId}`);\n    const hexAddress = chainId\n        ? `${chainId}${address_.toLowerCase()}`\n        : address_.substring(2).toLowerCase();\n    const hash = keccak256(stringToBytes(hexAddress), 'bytes');\n    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n            address[i] = address[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n            address[i + 1] = address[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${address.join('')}`;\n    checksumAddressCache.set(`${address_}.${chainId}`, result);\n    return result;\n}\nexport function getAddress(address, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (!isAddress(address, { strict: false }))\n        throw new InvalidAddressError({ address });\n    return checksumAddress(address, chainId);\n}\n//# sourceMappingURL=getAddress.js.map","import { LruMap } from '../lru.js';\nimport { checksumAddress } from './getAddress.js';\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function isAddress(address, options) {\n    const { strict = true } = options ?? {};\n    const cacheKey = `${address}.${strict}`;\n    if (isAddressCache.has(cacheKey))\n        return isAddressCache.get(cacheKey);\n    const result = (() => {\n        if (!addressRegex.test(address))\n            return false;\n        if (address.toLowerCase() === address)\n            return true;\n        if (strict)\n            return checksumAddress(address) === address;\n        return true;\n    })();\n    isAddressCache.set(cacheKey, result);\n    return result;\n}\n//# sourceMappingURL=isAddress.js.map","export function concat(values) {\n    if (typeof values[0] === 'string')\n        return concatHex(values);\n    return concatBytes(values);\n}\nexport function concatBytes(values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const arr of values) {\n        result.set(arr, offset);\n        offset += arr.length;\n    }\n    return result;\n}\nexport function concatHex(values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n//# sourceMappingURL=concat.js.map","import { SliceOffsetOutOfBoundsError, } from '../../errors/data.js';\nimport { isHex } from './isHex.js';\nimport { size } from './size.js';\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice(value, start, end, { strict } = {}) {\n    if (isHex(value, { strict: false }))\n        return sliceHex(value, start, end, {\n            strict,\n        });\n    return sliceBytes(value, start, end, {\n        strict,\n    });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n        throw new SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        size(value) !== end - start) {\n        throw new SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: size(value),\n        });\n    }\n}\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = value_.slice(start, end);\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = `0x${value_\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n//# sourceMappingURL=slice.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { abytes, aexists, anumber, aoutput } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","import { keccak_256 } from '@noble/hashes/sha3';\nimport { isHex } from '../data/isHex.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toHex } from '../encoding/toHex.js';\nexport function keccak256(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return toHex(bytes);\n}\n//# sourceMappingURL=keccak256.js.map","import { toSignatureHash, } from './toSignatureHash.js';\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash;\n//# sourceMappingURL=toEventSelector.js.map","import { slice } from '../data/slice.js';\nimport { toSignatureHash, } from './toSignatureHash.js';\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);\n//# sourceMappingURL=toFunctionSelector.js.map","import { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from './keccak256.js';\nconst hash = (value) => keccak256(toBytes(value));\nexport function hashSignature(sig) {\n    return hash(sig);\n}\n//# sourceMappingURL=hashSignature.js.map","import { execTyped } from '../regex.js';\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/;\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter(abiParameter) {\n    let type = abiParameter.type;\n    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n        type = '(';\n        const length = abiParameter.components.length;\n        for (let i = 0; i < length; i++) {\n            const component = abiParameter.components[i];\n            type += formatAbiParameter(component);\n            if (i < length - 1)\n                type += ', ';\n        }\n        const result = execTyped(tupleRegex, abiParameter.type);\n        type += `)${result?.array ?? ''}`;\n        return formatAbiParameter({\n            ...abiParameter,\n            type,\n        });\n    }\n    // Add `indexed` to type if in `abiParameter`\n    if ('indexed' in abiParameter && abiParameter.indexed)\n        type = `${type} indexed`;\n    // Return human-readable ABI parameter\n    if (abiParameter.name)\n        return `${type} ${abiParameter.name}`;\n    return type;\n}\n//# sourceMappingURL=formatAbiParameter.js.map","import { formatAbiParameter, } from './formatAbiParameter.js';\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters(abiParameters) {\n    let params = '';\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        params += formatAbiParameter(abiParameter);\n        if (i !== length - 1)\n            params += ', ';\n    }\n    return params;\n}\n//# sourceMappingURL=formatAbiParameters.js.map","import { formatAbiItem } from 'abitype';\nimport { normalizeSignature, } from './normalizeSignature.js';\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def) => {\n    const def_ = (() => {\n        if (typeof def === 'string')\n            return def;\n        return formatAbiItem(def);\n    })();\n    return normalizeSignature(def_);\n};\n//# sourceMappingURL=toSignature.js.map","import { formatAbiParameters, } from './formatAbiParameters.js';\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem(abiItem) {\n    if (abiItem.type === 'function')\n        return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n            ? ` ${abiItem.stateMutability}`\n            : ''}${abiItem.outputs?.length\n            ? ` returns (${formatAbiParameters(abiItem.outputs)})`\n            : ''}`;\n    if (abiItem.type === 'event')\n        return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'error')\n        return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\n    if (abiItem.type === 'constructor')\n        return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    if (abiItem.type === 'fallback')\n        return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;\n    return 'receive() external payable';\n}\n//# sourceMappingURL=formatAbiItem.js.map","import { BaseError } from '../../errors/base.js';\nexport function normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new BaseError('Unable to normalize signature.');\n    return result;\n}\n//# sourceMappingURL=normalizeSignature.js.map","import { hashSignature } from './hashSignature.js';\nimport { toSignature } from './toSignature.js';\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn) {\n    return hashSignature(toSignature(fn));\n}\n//# sourceMappingURL=toSignatureHash.js.map","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\n//# sourceMappingURL=regex.js.map","export const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {\n    const value = typeof value_ === 'bigint' ? value_.toString() : value_;\n    return typeof replacer === 'function' ? replacer(key, value) : value;\n}, space);\n//# sourceMappingURL=stringify.js.map"],"names":["anumber","n","Number","isSafeInteger","Error","abytes","b","lengths","a","Uint8Array","ArrayBuffer","isView","constructor","name","length","includes","aexists","instance","checkFinished","destroyed","finished","aoutput","out","min","outputLen","u32","arr","Uint32Array","buffer","byteOffset","Math","floor","byteLength","createView","DataView","rotr","word","shift","isLE","byteSwap","byteSwap32","i","toBytes","data","str","TextEncoder","encode","utf8ToBytes","Hash","clone","this","_cloneInto","wrapConstructor","hashCons","hashC","msg","update","digest","tmp","blockLen","create","execTyped","regex","string","match","exec","groups","bytesRegex","integerRegex","isTupleRegex","AbiConstructorNotFoundError","docsPath","super","join","AbiConstructorParamsNotFoundError","AbiDecodingDataSizeTooSmallError","params","size","metaMessages","includeName","Object","defineProperty","enumerable","configurable","writable","value","AbiDecodingZeroDataError","AbiEncodingArrayLengthMismatchError","expectedLength","givenLength","type","AbiEncodingBytesSizeMismatchError","expectedSize","AbiEncodingLengthMismatchError","AbiErrorSignatureNotFoundError","signature","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","AbiEventNotFoundError","eventName","AbiFunctionNotFoundError","functionName","AbiFunctionOutputsNotFoundError","AbiItemAmbiguityError","x","y","abiItem","BytesSizeMismatchError","givenSize","DecodeLogDataMismatch","DecodeLogTopicsMismatch","param","InvalidAbiEncodingTypeError","InvalidAbiDecodingTypeError","InvalidArrayError","InvalidDefinitionTypeError","InvalidAddressError","address","encodeAbiParameters","values","preparedParams","push","prepareParam","prepareParams","encodeParams","arrayComponents","getArrayComponents","dynamic","Array","isArray","dynamicChild","preparedParam","encoded","map","encodeArray","components","param_","encodeTuple","toLowerCase","encodeAddress","encodeBool","startsWith","signed","max","BigInt","toString","encodeNumber","paramSize","split","bytesSize","value_","dir","ceil","parseInt","encodeBytes","hexValue","partsLength","parts","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","matches","undefined","formatAbiItem","formatAbiParams","inputs","slice","formatAbiParam","getAbiItem","parameters","abi","args","isSelector","strict","abiItems","filter","matchedAbiItem","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","argType","abiParameterType","component","test","replace","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","checksumAddressCache","checksumAddress","address_","chainId","has","get","hexAddress","substring","hash","toUpperCase","result","set","getAddress","addressRegex","isAddressCache","isAddress","options","cacheKey","concat","concatHex","offset","concatBytes","reduce","acc","start","end","sliceHex","sliceBytes","assertStartOffset","position","assertEndOffset","U32_MASK64","_32n","fromBig","le","h","l","lst","Ah","Al","rotlSH","s","rotlSL","rotlBH","rotlBL","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","t","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","suffix","enableXOF","rounds","pos","posOut","state","state32","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","fill","keccakP","len","take","finish","writeInto","bufferOut","subarray","xofInto","xof","bytes","digestInto","destroy","to","gen","keccak_256","keccak256","to_","isHex","toHex","toEventSelector","toFunctionSelector","fn","tupleRegex","formatAbiParameter","array","indexed","formatAbiParameters","abiParameters","toSignature","def","active","current","level","valid","char","normalizeSignature","stateMutability","outputs","toSignatureHash","sig","LruMap","Map","maxSize","key","delete","firstKey","keys","next","stringify","replacer","space","JSON"],"sourceRoot":""}