{"version":3,"file":"chunk/6582.26ac1431.js","mappings":"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","sources":["webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/ws.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/ankr-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/fallback-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/ipc-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/infura-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/pocket-provider.js","webpack://@snx-v3/liquidity/../../node_modules/@ethersproject/providers/lib.esm/index.js"],"sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nexport class AlchemyWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arb-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-goerli\":\n                host = \"opt-goerli.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=alchemy-provider.js.map","import { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n}\n//# sourceMappingURL=ankr-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", { blockTag: \"latest\" });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n}\n//# sourceMappingURL=cloudflare-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = hexValue(hexlify(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || typeof (result.message) !== \"string\" || !result.message.match(/^OK/)) {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if (isHexString(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nexport class EtherscanProvider extends BaseProvider {\n    constructor(network, apiKey) {\n        super(network);\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || null);\n    }\n    getBaseUrl() {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"sepolia\":\n                return \"https:/\\/api-sepolia.etherscan.io\";\n            case \"matic\":\n                return \"https:/\\/api.polygonscan.com\";\n            case \"maticmum\":\n                return \"https:/\\/api-testnet.polygonscan.com\";\n            case \"arbitrum\":\n                return \"https:/\\/api.arbiscan.io\";\n            case \"arbitrum-goerli\":\n                return \"https:/\\/api-goerli.arbiscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-goerli\":\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n            const payload = (post ? this.getPostData(module, params) : null);\n            const procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url) => {\n                    if (this.isCommunityResource()) {\n                        showThrottleMessage();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                payloadStr = Object.keys(payload).map((key) => {\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: deepCopy(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (method) {\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error) => {\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: (params.includeTransactions ? \"true\" : \"false\")\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\": {\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"call\", error, params.transaction);\n                    }\n                }\n                case \"estimateGas\": {\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"estimateGas\", error, params.transaction);\n                    }\n                }\n                case \"getLogs\": {\n                    const args = { action: \"getLogs\" };\n                    if (params.filter.fromBlock) {\n                        args.fromBlock = checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        args.toBlock = checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        args.address = params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            args.topic0 = topic0;\n                        }\n                    }\n                    const logs = yield this.fetch(\"logs\", args);\n                    // Cache txHash => blockHash\n                    let blocks = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (blocks[log.blockNumber] == null) {\n                            const block = yield this.getBlock(log.blockNumber);\n                            if (block) {\n                                blocks[log.blockNumber] = block.hash;\n                            }\n                        }\n                        log.blockHash = blocks[log.blockNumber];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = {\n                action: \"txlist\",\n                address: (yield this.resolveName(addressOrName)),\n                startblock: ((startBlock == null) ? 0 : startBlock),\n                endblock: ((endBlock == null) ? 99999999 : endBlock),\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx) => {\n                [\"contractAddress\", \"to\"].forEach(function (key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return (this.apiKey == null);\n    }\n}\n//# sourceMappingURL=etherscan-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                if (method === \"call\" && params.blockTag) {\n                    return provider[method](params.transaction, params.blockTag);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map","\"use strict\";\nconst IpcProvider = null;\nexport { IpcProvider };\n//# sourceMappingURL=ipc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nexport class InfuraWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"sepolia\":\n                host = \"sepolia.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-goerli\":\n                host = \"optimism-goerli.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arbitrum-goerli.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n//# sourceMappingURL=infura-provider.js.map","import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map","/* istanbul ignore file */\n\"use strict\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n//# sourceMappingURL=nodesmith-provider.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\nexport class PocketProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: true,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (apiKey == null) {\n            apiKeyObj.applicationId = defaultApplicationId;\n        }\n        else if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n        }\n        else if (apiKey.applicationId) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"kovan\":\n                host = \"poa-kovan.gateway.pokt.network\";\n                break;\n            case \"matic\":\n                host = \"poly-mainnet.gateway.pokt.network\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai-rpc.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        const connection = { headers: {}, url };\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationId);\n    }\n}\n//# sourceMappingURL=pocket-provider.js.map","\"use strict\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { BaseProvider, Resolver } from \"./base-provider\";\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\":\n                case \"https\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                case \"wss\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider,\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n        IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\nexport { \n// Abstract Providers (or Abstract-ish)\nProvider, BaseProvider, Resolver, UrlJsonRpcProvider, \n///////////////////////\n// Concrete Providers\nFallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, AnkrProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, \n///////////////////////\n// Signer\nJsonRpcSigner, \n///////////////////////\n// Functions\ngetDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, \n///////////////////////\n// Objects\nFormatter };\n//# sourceMappingURL=index.js.map"],"names":["WS","WebSocket","Error","error","logger","Logger","throwError","errors","UNSUPPORTED_OPERATION","operation","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","NextId","WebSocketProvider","constructor","url","network","super","this","_pollingInterval","_wsReady","defineReadOnly","connection","detectNetwork","websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","String","request","undefined","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","pollingInterval","resetEventsBlock","blockNumber","poll","polling","rid","stringify","jsonrpc","static","_subscribe","tag","param","subIdPromise","_subIds","all","subId","_startEvent","event","type","from","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","_stopEvent","length","listenerCount","destroy","readyState","CONNECTING","onerror","close","StaticJsonRpcProvider","_super","create","get","call","UNKNOWN_ERROR","_network","UrlJsonRpcProvider","apiKey","checkAbstract","getStatic","key","_startPending","isCommunityResource","getSigner","address","listAccounts","NOT_IMPLEMENTED","defaultApiKey","AlchemyWebSocketProvider","AlchemyProvider","replace","throwArgumentError","host","name","arguments","allowGzip","throttleCallback","attempt","getHost","AnkrProvider","projectSecret","user","password","CloudflareProvider","perform","blockTag","getTransactionPostData","transaction","gasLimit","gasPrice","maxFeePerGs","maxPriorityFeePerGas","nonce","hexValue","hexlify","accessListify","map","set","storageKeys","join","getResult","status","match","toLowerCase","indexOf","throttleRetry","getJsonResult","checkLogTag","parseInt","substring","checkError","SERVER_ERROR","isHexString","CALL_EXCEPTION","body","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","EtherscanProvider","getBaseUrl","getUrl","module","query","reduce","accum","baseUrl","getPostUrl","getPostData","apikey","fetch","post","procFunc","throttleSlotInterval","payloadStr","headers","fetchJson","deepCopy","position","hex","signedTransaction","catch","boolean","includeTransactions","txhash","transactionHash","postData","args","fromBlock","toBlock","topics","topic0","logs","blocks","i","blockHash","getBlock","parseFloat","ethusd","getHistory","addressOrName","startBlock","endBlock","resolveName","startblock","endblock","sort","tx","creates","contractAddress","item","transactionResponse","timeStamp","timestamp","now","Date","getTime","checkNetworks","networks","chainId","ensAddress","median","values","maxDelta","slice","middle","Math","floor","a","b","abs","serialize","isBigNumber","toString","Array","isArray","v","nextRid","stall","duration","cancel","timer","promise","clearTimeout","setTimeout","getPromise","wait","func","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","start","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","shallowCopy","confirmations","transactions","quorum","tally","count","check","normalizedTally","waitForSync","cancelled","oncePoll","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","getLogs","FallbackProvider","providers","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","freeze","total","networkOrReady","getNetwork","results","sendTransaction","getBlockNumber","shuffle","first","t0","inflightWeight","runner","staller","backend","waiting","push","race","errorCode","props","reason","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","projectId","apiKeyObj","assertArgument","INVALID_ARGUMENT","argument","JsonRpcBatchProvider","_nextId","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationId","PocketProvider","applicationId","loadBalancer","applicationSecretKey","getDefaultProvider","options","n","_defaultProvider","NETWORK_ERROR","JsonRpcProvider","Web3Provider"],"sourceRoot":""}